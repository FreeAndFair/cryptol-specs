/**
 * Convenience functions for working with `Option`s.
 */
module Common::OptionUtils where

isSome : {a} Option a -> Bit
isSome opt = case opt of
    Some _ -> True
    None -> False

isNone : {a} Option a -> Bit
isNone opt = ~ isSome opt

/**
 * Map an `Option a` to an `Option b` by applying a function to a contained
 * value (if `Some`) or returns `None` (if `None`).
 */
mapOption : {a, b} (a -> b) -> Option a -> Option b
mapOption f opt = case opt of
    Some x -> Some (f x)
    None -> None

/**
 * Flatten a nested option into a single option.
 */
flatten : {a} Option (Option a) -> Option a
flatten opt = case opt of
    Some opt' -> opt'
    None -> None

/**
 * Map an `Option a` to an `Option b` by calling `mapOption` on a function that
 * produces an `Option b`, then flattening the result.
 */
flatMap : {a, b} (a -> Option b) -> Option a -> Option b
flatMap f opt = flatten (mapOption f opt)