/*

General utility functions for use across implementations.

@copyright Galois, Inc
@copyright Amazon.com or its affiliates.

@author Sean Weaver
@author Nichole Schmanski <nls@galois.com>
@author Rob Dockins
@author Andrei Stefanescu
@editor Ryan Scott <rscott@galois.com>
@editor Rod Chapman <rodchap@amazon.com>

*/
module Common::utils where

while : {a} (a -> Bit) -> (a -> a) -> a -> a
while condition body initial_state =
  if(condition initial_state) then while condition body (body initial_state)
  else initial_state

dowhile : {a} (a -> Bit) -> (a -> a) -> a -> a
dowhile condition body initial_state =
  if(condition next_state) then while condition body next_state else next_state
  where next_state = body initial_state

ZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]
ZtoBV x = (fromInteger (fromZ x))

BVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p
BVtoZ x = (fromInteger (toInteger x))

ZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q
ZtoZ x = (fromInteger (fromZ x))

integerToBV : {m} (fin m) => Integer -> [m]
integerToBV x = fromInteger x

integerFromBV : {m} (fin m) => [m] -> Integer
integerFromBV x = toInteger x

integerModulusFromBV : {m} (fin m) => [m] -> Integer
integerModulusFromBV x = if (integerFromBV x) < 3 then 3 else (integerFromBV x)

isEven : Integer -> Bit
isEven x = ~((fromInteger x) : [1]) ! 0

abs : Integer -> Integer
abs x = if x >= zero then x else zero-x

unzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)
unzip tuples = (map (\x -> x.0) tuples , map (\x -> x.1) tuples)

mul2 x = x + x
mul3 x = x + mul2 x
mul4 x = mul2(mul2 x)
mul8 x = mul2(mul4 x)

type constraint isOdd a = (a / 2) * 2 == a - 1

half : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p
half x = fromInteger (if isEven xint then xint/2 else ((xint + `p) / 2))
  where
    xint = fromZ x

half_correct : {p} (fin p, p >= 3, isOdd p) => Z p -> Bit
property half_correct x = half x + half x == x

/**
 * Function composition, specialized to functions from `(a -> a)`.
 */
compose : {a} () => (a -> a) -> (a -> a) -> a -> a
compose f g = \x -> g (f x)

/**
 * Composition of many functions from `(a -> a)`.
 */
composeMany : {nf, a} () => [nf](a -> a) -> a -> a
composeMany fcns
    | nf == 0 => \x -> x
    | nf == 1 => fcns@0
    | nf == 2 => compose (fcns@0) (fcns@1)
    | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))
