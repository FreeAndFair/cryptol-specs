/**
 * Modular division for Z n types
 *
 * @copyright Galois, Inc.
 * @author Max Orhai
 */

module Common::ModDivZ where

/**
 * Check if some `k` is even.
 * ```repl
 * :prove even 2
 * :prove ~even 7
 * ```
 */
even k = k % 2 == 0

/**
 * Calulate x / y in F_p using Euler's binary gcd algorithm.
 * ```repl
 * :prove moddiv `{3} 2 2 == 1
 * ```
 */
moddiv : {p}(fin p, p >= 3, prime p) => Z p -> Z p -> Z p
moddiv x y = if y == 0 then error "division by 0"  // zero has no inverse
                       else fromInteger (egcd `p 0 (fromZ y) (fromZ x))
    where

    egcd : Integer -> Integer -> Integer -> Integer -> Integer
    egcd a ra b rb =  // a odd!
        if b == 0 then ra
         | even b then egcd a ra (   b    / 2) (half rb)
         | a < b  then egcd a ra ((b - a) / 2) (half ((rb - ra) % `p))
                  else egcd b rb ((a - b) / 2) (half ((ra - rb) % `p))

    half : Integer -> Integer
    half k = (if even k then k else (k + `p)) / 2

(%/) = moddiv  // infix form of operator
