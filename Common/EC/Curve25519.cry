/**
 * Curve 25519 is an elliptic curve commonly used
 * in ECDH, standardized as an alternative to NIST
 * curves.
 *
 * References:
 *  [rfc 7748]
 *  Elliptic Curves for Security (IRTF RFC 7748)
 *  Langley, Google, Hamburg, Rambus Cryptography Research,
 *  Turner, sn3rd
 *  January 2016
 *  @see https://datatracker.ietf.org/doc/html/rfc7748
 */

module Common::EC::Curve25519 where

/*
 * Curve 25519 is a Montgomery curve of the form
 * `v^2 = u^3 + A * u^2 + u` over a prime `p`.
 *
 * Reference:
 * [rfc7748] Section 4.1
 */

/**
 * The prime defining the field
 */
type p = 2^^255 - 19

/**
 * The coefficient `A`.
 */
type A = 48662

/**
 * The order of the curve.
 */
type order = 2^^252 + 27742317777372353535851937790883648493

/**
 * The specification uses hexadecimal notation to define the curve order.
 *
 * ```repl
 * :prove orderOk
 * ```
 */
property orderOk = `order == order'
    where
        i = toInteger 0x14def9dea2f79cd65812631a5cf5d3ed
        order' = 2^^252 + i

/**
 * The `u`-coordinate of the base point `(Gu, Gv)`
 */
type Gu = 9

/**
 * The `v`-coordinate of the base point `(Gu, Gv)`
 */
type Gv = 14781619447589544791020593568409986887264606134616475288964881837755586237401


/**
 * The elements of the Galois field where computations
 * take place are encoded as little-endian arrays
 * of bytes. Cryptol defaults to a big-endian
 * representation.
 *
 * Reference:
 * [rfc7748] Section 5.
 */
little : {n} (fin n) => [n][8] -> [n][8]
little x = reverse x

/**
 * Little endian conversion is an involution.
 *
 * ```repl
 * :prove littleInvolution `{100}
 * ```
 */
littleInvolution : {n} (fin n) => [n][8] -> Bit
property littleInvolution x = little (little x) == x

/**
 * Take an array of bytes, and encode this
 * as a value modulo `p`.
 *
 * This implementation utilizes Cryptol
 * intrinsics rather than attempting to follow
 * the Python reference implementation provided
 * in [rfc7748] Section 5.
 *
 * ```repl
 * :prove decodeLittleEndian' `{16} [0x7f, 0xff] == fromInteger(toInteger 0xff7f)
 * ```
 */
decodeLittleEndian' : {bits} (fin bits) => [bits /^ 8][8] -> Z p
decodeLittleEndian' x = fromInteger (toInteger (join (little x)))

/**
 * Take an array of bytes and decode as a little endian number.
 * Folow the specification. Assume that the array is "already"
 * little endian.
 */
decodeLittleEndian : {bits} (fin bits) => [bits /^ 8][8] -> Z p
decodeLittleEndian x = fromInteger (sum iterates)
    where
        lshft y i = y * 256 ^^ i // left shift on integers
        iterates = [lshft (toInteger b) i | b <- x | i <- [0..bits /^ 8]]

/**
 * Both decoding versions are equivalent.
 *
 * ```repl
 * :prove decodeLittleEndianOk `{16}
 * ```
 */
decodeLittleEndianOk : {bits} (fin bits) => [bits /^ 8][8] -> Bit
property decodeLittleEndianOk x = decodeLittleEndian `{bits} x == decodeLittleEndian' `{bits} x

/**
 * Take a `Z p` value and encode it as an array of bytes.
 * This does not appear in the specification verbatim; it is
 * included to assure the implementation of `decodeLittleEndian`.
 */
encodeLittleEndian : {n} (fin n) => Z p -> [n][8]
encodeLittleEndian x = little (split y)
    where
        i = fromZ x
        y = fromInteger i : [n * 8]

/**
 * If the byte array is a canonical member of `Z p`
 * after decoding, then `decodeLittleEndian` inverts
 * `encodeLittleEndian` if `n` is large enough to hold
 * the reuslt with truncation.
 *
 * ```repl
 * :check encodeOk
 * ```
 */
encodeOk : Z p -> Bit
property encodeOk x = decodeLittleEndian `{255} (encodeLittleEndian `{32} x) == x


/**
 * Decode the `u` coordinate with the "mask".
 * For X25519, the bits parameter is 255.
 *
 * Assume the array is already "little endian".
 */
decodeUCoordinate : {bits} (fin bits) => [(bits + 7) / 8][8] -> Z p
decodeUCoordinate = undefined



/**
 * Scalars are assumed to be randomly generated bytes.
 * For curve 25519, we need 32 bytes, and we mask
 * the final bit (i.e., assume that it is zero).
 */
decodeScalar = undefined
