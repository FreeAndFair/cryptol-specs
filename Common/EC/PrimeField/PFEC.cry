/*
 NIST-standardized Prime Field Elliptic Curves in short-Weierstrass form.

 This contains an implementation of elliptic curve operations for curves
 in short-Weierstrass form, defined over the finite field GF(P), where P
 is an odd prime power (short-Weierstrass form can also be used over the
 binary field GF(2^m), but curves of this form were deprecated in
 [SP-800-186] Section 3.3 and are not supported by this implementation).

 This implementation has several restrictions that tie it specifically to
 the NIST-standardized curves:
 - it fixes the curve parameter `a = -3`;
 - it fixes the cofactor `h = 1`;
 - it requires that the finite field `GF(P)` is over a prime `P` (not a power).

 This implementation draws from several sources:
 - The NIST recommendation for elliptic curves defines allowable domain
   parameters and the group operation (`affine_add`) [SP-800-186].
 - The digital signature standard includes some elliptic curve operations
   needed to implement ECDSA [FIPS-186-5].
 - Additional routines for elliptic curves are defined in [MATH-2008].
 - The SEC1 standard consolidates many of the other resources cited herein.
   In some cases, we refer to both the original source and [SEC1-v2].

 References
 [FIPS-186-5]: National Institute of Standards and Technology. Digital
   Signature Standard (DSS). (Department of Commerce, Washington, D.C.),
   Federal Information Processing Standards Publication (FIPS) NIST FIPS 186-5.
   February 2023.
   https://doi.org/10.6028/NIST.FIPS.186-5
 [MATH-2008]: Mathematical routines for the NIST prime elliptic curves.
    March 2008.
    https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=e1b05e600bfcdeecf8555bc9948483c5fbbdd478
 [SP-800-186]: Lily Chen, Dustin Moody, Karen Randall, Andrew Regenscheid,
    Angela Robinson. Recommendations for Discrete Logarithm-based Cryptography:
    Elliptic Curve Domain Parameters. (National Institute of Standards and
    Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST SP
    800-186. February 2023.
    https://doi.org/10.6028/NIST.SP.800-186
  [SEC1-v2]: Daniel R. L. Brown. SEC 1: Elliptic Curve Cryptography, Version
    2.0. Standards for Efficient Cryptography Group. May 2009.
    http://www.secg.org/sec1-v2.pdf
  [SEC2-v2]: Daniel R. L. Brown. SEC 2: Recommened Elliptic Curve Domain
    Parameters, Version 2.0. Standards for Efficient Cryptography Group. Jan
    2010.
    https://www.secg.org/sec2-v2.pdf

@copyright Galois, Inc
@author Max Orhai
@author Marcella Hastings <marcella@galois.com>
@author Sean Weaver
*/

module Common::EC::PrimeField::PFEC where

import Common::ModDivZ
import Common::utils(half, mp_mod_inv, mul2, mul3, mul4, mul8, ZtoBV)

parameter
    /**
     * Field size `P`.
     * P must be an odd prime power and is not divisible by 3.
     * I don't think there's a way to enforce "prime power" in the type
     * constraint, but for the NIST curves, every `P` itself is prime,
     * so we use the simpler constraint `prime P`.
     * [SP-800-186] Section 2.1.1.
     */
    type P : #
    type constraint (fin P, prime P, P >= 5, P % 2 == 1, P % 3 != 0)

    /**
     * Order of the base point `G = (Gx, Gy)`. This must be prime.
     * [SP-800-186] Section 2.1.1.
     */
    type n : #
    type constraint (fin n, prime n, n < P)

    /**
     * Coefficients that define the curve.
     * For a curve in short-Weierstrass form, the equation is
     * `y^2 = x^3 + ax + b`.
     * See the `curveCoefficientsAreValid` property.
     * [SP-800-186] Section 2.1.1.
     */
    b : Z P

    /**
     * Coordinates of the base point `G = (Gx, Gy)`.
     */
    Gx : Z P
    Gy : Z P

/*
 * Coefficient that defines the curve.
 * For a curve in short-Weierstrass form, the equation is
 * `y^2 = x^3 + ax + b`.
 * See the `curveCoefficientsAreValid` property.
 * [SP-800-186] Section 2.1.1.
 *
 * Due to restrictions on the underlying elliptic curve operations, the
 * a-coordinate must be -3. This is the case for all NIST-standardized
 * prime order fields in short-Weierstrass form.
 */
a = -3 : Z P

/**
 * Cofactor for the curve.
 *
 * The order of the curve is defined as `h * n`, where `h` is small
 * and `n`, the order of the base point `G`, is prime. If `h` is not
 * 1, then the base point does not generate the entire curve.
 *
 * This is fixed to 1 for all the NIST-standardized prime order fields
 * in short-Weierstrass form. It's not necessarily true for all reasonable
 * elliptic curves.
 */
h = 1 : Integer


/**
 * A point that satisfies the curve equation `y^2 = x^3 + ax + b`.
 * Sometimes this is called an "affine" representation.
 * [SP-800-186] Section 2.1.1.
 */
enum Point = Infinity | Affine (Z P) (Z P)

/**
 * Check equality of two affine points.
 *
 * I don't know if this is explicitly specified anywhere because it's just
 * by definition.
 */
affineEq : Point -> Point -> Bool
affineEq p1 p2 = case p1 of
  Infinity -> case p2 of
      Infinity -> True
      _ -> False
  Affine x y -> case p2 of
      Affine x' y' -> (x == x') && (y == y')
      _ -> False

/**
 * Check that a given point is on the curve -- either it is the point at
 * infinity or it satisfies the curve equation.
 * [SP-800-186] Section 2.1.1.
 * [SEC1-v2] Section 2.2.1.
 * [MATH-2008] Routine 2.2.5.
 */
valid_point : Point -> Bit
valid_point point = case point of
    Infinity -> True
    Affine x y -> (y ^^ 2 == x ^^ 3 + a * x + b)

/**
 * Convenient `Point` representation of the base point `G`.
 */
G = Affine Gx Gy : Point

/**
 * For curves in short-Weierstrass form, the following inequality must hold:
 *      4a^3 + 27b^2 != 0
 * [SP-800-186] Section 2.1.1.
 *
 * ```repl
 * :prove curveCoefficientsAreValid
 * ```
 */
property curveCoefficientsAreValid = (4 * a^^3 + _27 * b^^2 != 0)
    where
        _27 : Z P
        _27 = fromInteger 27

/**
 * G must be of order `n`.
 * ```repl
 * :prove gOrderIsN
 * ```
 */
property gOrderIsN = affineEq G ((`n + 1) ~* G)

/**
 * Add two elliptic curve points together.
 */
add : Point -> Point -> Point
add p1 p2 = to_affine (ec_full_add (to_projective p1) (to_projective p2))

/**
 * Double an elliptic curve point.
 */
double : Point -> Point
double p = to_affine (ec_double (to_projective p))

/**
 * Subtract one curve point from another.
 */
sub : Point -> Point -> Point
sub p1 p2 = to_affine (ec_full_sub (to_projective p1) (to_projective p2))

/**
 * Scalar multiplication of a curve point.

 * Scalar multiplication is the process of adding `P` to itself `k` times
 * for an integer `k`.
 *
 * [SEC1-v2] Section 2.2.1 doesn't explicitly specify an algorithm, but it
 * notes that it can be computed efficiently using the addition rule and a
 * variant of the double-and-add algorithm.
 * In this implementation, we use a variant from [MATH-2008] (see `ec_mult`).
 */
scmul : Integer -> Point -> Point
scmul k p = to_affine (ec_mult (fromInteger k) (to_projective p))

(~*) = scmul  // infix form of operator

/**
 * Scalar multiplication of a curve point must also be on the curve.
 * ```repl
 * :check valid_scmul
 * ```
 */
property valid_scmul m = valid_point (m ~* G)

/**
 * Scalar multiplication is commutative.
 * ```repl
 * :check valid_scmul
 * ```
 */
property scmul_commutes m m' = affineEq (m ~* (m' ~* G)) (m' ~* (m ~* G))

private
    type ProjectivePoint = { x : Z P, y : Z P, z : Z P }
    InfinityProjective = { x=1, y=1, z=0 }
    Zero = { x=0, y=0, z=0 }

    /**
     * Convert from an affine to a projective representation.
     * [MATH-2008] Routine 2.2.1.
     */
    to_projective : Point -> ProjectivePoint
    to_projective p = case p of
        Infinity -> InfinityProjective
        Affine x y -> { x=x, y=y, z=1 }

    /**
     * Convert from a projective to an affine representation.
     * [MATH-2008] Routine 2.2.2.
     */
    to_affine : ProjectivePoint -> Point
    to_affine p =
        // The point at infinity does not have an affine representation.
        if p.z == 0 then Infinity
        else Affine (lambda ^^2 * p.x) (lambda ^^3 * p.y)
      where
        lambda = mp_mod_inv p.z

    /**
     * Double an elliptic curve point.
     * [MATH-2008] Routine 2.2.6.
     *
     * Requires that curve parameter `a = -3 mod P`
     */
    ec_double : ProjectivePoint -> ProjectivePoint
    ec_double S =
      if S.z == 0 then InfinityProjective /* 5: r <- (1,1,0) and return */
      else
        {x = r18, y = r23, z = r13}
      where r7  = S.z ^^ 2                /*  7: t4 <- (t3)^2 */
            r8  = S.x - r7                /*  8: t5 <- t1 - t4 */
            r9  = S.x + r7                /*  9: t4 <- t1 + t4 */
            r10 = r9 * r8                 /* 10: t5 <- t4 * t5 */
            r11 = mul3 r10                /* 11: t4 <- 3 * t5 */
            r12 = S.z * S.y               /* 12: t3 <- t3 * t2 */
            r13 = mul2 r12                /* 13: t3 <- 2 * t3 */
            r14 = S.y ^^ 2                /* 14: t2 <- (t2)^2 */
            r15 = S.x * r14               /* 15: t5 <- t1 * t2 */
            r16 = mul4 r15                /* 16: t5 <- 4 * t5 */
            r17 = r11 ^^ 2                /* 17: t1 <- (t4)^2 */
            r18 = r17 - (mul2 r16)        /* 18: t1 <- t1 - 2 * t5 */
            r19 = r14 ^^ 2                /* 19: t2 <- (t2)^2 */
            r20 = mul8 r19                /* 20: t2 <- 8 * t2 */
            r21 = r16 - r18               /* 21: t5 <- t5 - t1 */
            r22 = r11 * r21               /* 22: t5 <- t4 * t5 */
            r23 = r22 - r20               /* 23: t2 <- t5 - t2 */

    /**
     * Addition of two elliptic curve points.
     *
     * This will fail in the case where either of the input points are the
     * point at infinity or if the two input points are the same (if they
     * are the same, will return a default value of (0,0,0)).
     * [MATH-2008] Routine 2.2.7.
     */
    ec_add : ProjectivePoint -> ProjectivePoint -> ProjectivePoint
    ec_add S T =
      if r13 == 0 then
        if r14 == 0 then Zero       /* 17: r <- (0,0,0) and return */
        else InfinityProjective     /* 19: r <- (1,1,0) and return */
      else
        {x = r32, y = r37, z = r27} /* 38: Rx <- t1; Ry <- t2, Rz <- t3 */
      where (t1, t2, t3, t4, t5, t6) = if T.z == 1
              then (S.x, S.y, S.z, T.x, T.y, T.z) /* 1: we set t6 = 1 to make L25 work */
              else (r5, r7, S.z, T.x, T.y, r3)

            r3 = T.z                /* 3: t6 <- T_z */
            r4 = r3 ^^ 2            /* 4: t7 <- t6^2 */
            r5 = S.x * r4           /* 5: t1 <- t1 * t7 */
            r6 = r3 * r4            /* 6: t7 <- t6 * t7 */
            r7 = S.y * r6           /* 7: t2 <- t2 * t7 */

            r9  = t3 ^^ 2           /*  9: t7 <- (t3)^2 */
            r10 = t4 * r9           /* 10: t4 <- t4 * t7 */
            r11 = t3 * r9           /* 11: t7 <- t3 * t7 */
            r12 = t5 * r11          /* 12: t5 <- t5 * t7 */
            r13 = t1 - r10          /* 13: t4 <- t1 - t4 */
            r14 = t2 - r12          /* 14: t5 <- t2 - t5 */

            r22 = mul2 t1 - r13     /* 22: t1 <- 2*t1 - t4 */
            r23 = mul2 t2 - r14     /* 23: t2 <- 2*t2 - t5 */

            r25 = t3 * t6           /* 25: t3 <- t3 * t6 if Tz =/= 1.
                                       If T.z == 1, then t6 == 1 and this is a no-op */

            r27 = r25 * r13          /* 27: t3 <- t3 * t4 */
            r28 = r13 ^^ 2           /* 28: t7 <- (t4)^2 */
            r29 = r13 * r28          /* 29: t4 <- t4 * t7 */
            r30 = r22 * r28          /* 30: t7 <- t1 * t7 */
            r31 = r14 ^^ 2           /* 31: t1 <- (t5)^2 */
            r32 = r31 - r30          /* 32: t1 <- t1 - t7 */
            r33 = r30 - (mul2 r32)   /* 33: t7 <- t7 - 2*t1 */
            r34 = r14 * r33          /* 34: t5 <- t5 * t7 */
            r35 = r23 * r29          /* 35: t4 <- t2 * t4 */
            r36 = r34 - r35          /* 36: t2 <- t5 - t4 */
            r37 = half r36           /* 37: t2 <- t2/2 */


    /**
     * Checked addition of two elliptic curve points.
     *
     * This method handles the cases where either of the input points are the
     * point at infinity or if the input points are the same.
     * [MATH-2008] Routine 2.2.8.
     */
    ec_full_add : ProjectivePoint -> ProjectivePoint -> ProjectivePoint
    ec_full_add S T =
      if S.z == 0 then T
       | T.z == 0 then S
       | R == {x = 0, y = 0, z = 0} then ec_double S
       else R
      where R = ec_add S T

    /**
     * Checked subtraction of two elliptic curve points.
     *
     * This method handles the cases where either of the input points are the
     * point at infinity or if the input points are the same.
     * [MATH-2008] Routine 2.2.8.
     */
    ec_full_sub : ProjectivePoint -> ProjectivePoint -> ProjectivePoint
    ec_full_sub S T = R
      where U = {x = T.x, y = -T.y, z = T.z}
            R = ec_full_add S U

    /**
     * Scalar multiplication on projective points
     * [MATH-2008] Routine 2.2.10.
     *
     * The routine requires that 0 <= d < P. We enforce this constraint by
     * setting the type of `d` to be `Z P`, then converting it to an integer
     * for all actual uses.
     */
    ec_mult : Z P -> ProjectivePoint -> ProjectivePoint
    ec_mult d S =
      if d == 0 then to_projective Infinity
       | d == 1 then S
       | S.z == 0 then to_projective Infinity
      else Rs ! 1 /* the iteration stops at 1, not 0 */
      where
        S' = if S.z != 1 then to_projective (to_affine S) else S
        // Get bits of `d` and `3d`. The width of `ks` is set to be large
        // enough to hold the full width of `hs`.
        ks = ZtoBV d : [width P + 2]
        hs = 3 * ks

        // The specified routine initializes R = S and skips the first high-bit
        // of `hs`, assuming that it's 1. Since we're a little floppy with our
        // bitwise conversion, we'll start at 0 and iterate over all the bits.
        Rs = [ InfinityProjective ] #
             [ if hi && ~ki then ec_full_add doubleR S
                | ~hi && ki then ec_full_sub doubleR S
                else doubleR
               where doubleR = ec_double Ri
             | ki <- ks | hi <- hs | Ri <- Rs ]

    /**
     * Addition of two elliptic curve points on a prime-field curve with
     * coefficient 'a'. Note 'b' is unused.
     * [SP-800-186] Appendix A.1.1.
     * [SEC1-v2] Section 2.2.1.
     *
     * This uses the less-efficient affine representation.
     */
    affine_add : Point -> Point -> Point
    affine_add point1 point2 = case point1 of
        Infinity -> point2
        Affine x1 y1 -> case point2 of
            Infinity -> point1
            Affine x2 y2 -> if (x1 == x2) && (y1 == -y2) then Infinity
                else Affine x y
                where  // all arithmetic operations are mod p
                    x = lambda ^^ 2 - x1 - x2
                    y = lambda * (x1 - x) - y1
                    lambda = if x1 == x2 then (3 * x1 ^^ 2 + a) %/ (2 * y1)
                        else (y2 - y1) %/ (x2 - x1)


    /**
     * Compute a valid curve point from a random `k` and the base point `G`.
     *
     * `k` is in the range [0, h * n), where `h * n` is the order of the
     * elliptic curve.
     * All the standardized NIST prime-order curves have (as the name suggests)
     * prime order and cofactor 1.
     *
     * NB: If the cofactor `h` is not 1, this function will not derive points
     * on the curve uniformly. When the cofactor is 1, that means the group is
     * cyclic and can be generated by a single point. When it's not 1, the group
     * has a large cyclic subgroup that is generated by `G`, but it's not the
     * entire group.
     *
     * The scalar multiplication specification specifically allows
     * multiplication by `k` in the range [0, P), hence the conversion.
     */
    validPointFromK : Z n -> Point
    validPointFromK k = to_affine (ec_mult _k (to_projective G))
      where
        _k : Z P
        _k = fromInteger (toInteger (ZtoBV k : [width P]))

    /**
     * Proof that the affine and projective versions of addition are equivalent.
     * This doesn't test the point at infinity.
     *
     * ```repl
     * :check addsAreEquivalent
     * ```
     */
    addsAreEquivalent : Z n -> Z n -> Bool
    property addsAreEquivalent k1 k2 =
        affineEq (affine_add p1 p2) (to_affine (ec_full_add (to_projective p1) (to_projective p2)))
        where
            p1 = validPointFromK k1
            p2 = validPointFromK k2

    /**
     * Proof that both addition properties work correctly for the point at infinity.
     *
     * ```repl
     * :check addsBehaveCorrectlyAtInfinity
     * ```
     */
    addsBehaveCorrectlyAtInfinity : Z n -> Bool
    property addsBehaveCorrectlyAtInfinity k = oo && ok && ko && oo' && ok' && ko'
        where
            // Compute infinity identies in affine form.
            point = validPointFromK k
            oo = affineEq Infinity (affine_add Infinity Infinity)
            ok = affineEq point (affine_add Infinity point)
            ko = affineEq point (affine_add point Infinity)

            // Compute infinity identies in projective form.
            point' = to_projective point
            oo' = InfinityProjective == ec_full_add InfinityProjective InfinityProjective
            ok' = point' == ec_full_add InfinityProjective point'
            ko' = point' == ec_full_add point' InfinityProjective

