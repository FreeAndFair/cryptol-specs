/**
 * The sponge construction is a method of instantiating a function with
 * arbitrary output length based upon a fixed-length transformation,
 * such as a hash function. The sponge construction was famously used
 * in the design of Keccak and SHA-3.
 *
 * The sponge construction in its generic form is interesting in its
 * right. This module implements the sponge construction as a
 * parameterized module.
 *
 * References:
 * [SPONGE]
 *    Cryptographic Sponge Functions (Version 0.1)
 *    Bertoni, Daemen, Peeters, Van Assche
 *    January 14, 2011
 *    @see https://keccak.team/files/CSF-0.1.pdf
 *
 * @copyright Galois, Inc.
 * @author John Christensen <jchristensen@galois.com>
 *
 */

module Primitive::Keyless::Sponge::Specification where

parameter
    /**
     * The sponge construction is based on a fixed-length transformation.
     * Optionally, this transformation is a permutation. The fixed length
     * of the transformation is called the width of the transformation,
     * and is denoted by `b` in Section 1.2 of [SPONGE].
     *
     * `b` is a number of bits.
     */
    type b: #

    /**
     * The sponge construction requires a value `r`, called the bitrate.
     * This term is first used in Section 1.2 of [SPONGE].
     */
    type r: #

    /**
     * The sponge construction requires a value `c`, called the capacity.
     * This term is first used in Section 1.2 of [SPONGE].
     */
    type c: #

    /**
     * The sponge construction operates on a state of `b` bits.
     * In Section 1.2 of [SPONGE], it is defined that `b = r + c`.
     */
    type constraint (b == r + c)

    /**
     * The sponge construction is based on a fixed-length transformation.
     * The particular transformation is called `f` in Section 1.2 of [SPONGE].
     */
    f : [b] -> [b]

/**
 * Condense a verbose type constraint.
 */
type constraint Fin A B C D = (fin A, fin B, fin C, fin D)

/**
 * A padding rule used in the sponge construction must be sponge compliant.
 * This notion is defined in Section 2.1.2 Definition 1 of [SPONGE], and
 * is partially modeled here as a property of the specification.
 * Specifically, this models compliance with the formula 2.1
 * of Definition 1.
 *
 * Here, `L` and `L'` represent the lengths of the messages in bits.
 * `P` and `P'` represent the length of the padding returned by the padding
 * function. We may replace the actual padding function with its output
 * in this property without loss of soundness because Section 2.1.2 states
 * that padding rules compliant with the sponge construction must be fully
 * determined from the message length and the block length.
 */
spongeInequalityCondition:
    {L, L', P, P'} (Fin L L' P P') =>
    [P] -> [P'] -> [L] -> [L'] -> Bit
spongeInequalityCondition p p' M M'
    | (L == L', P >= P') => M != M' ==> (M # p) != (M' # p' # zero)
    | (L == L', P <  P') => M != M' ==> (M' # p') != (M # p # zero)
    | (L + P >= L' + P') => (M # p) != (M' # p' # zero)
    | (L + P <  L' + P') => (M' # p') != (M # p # zero)

/**
 * A sponge compliant padding rule must not return the empty bitstring
 * for any message.
 */
spongeNonempty: {P} () => [P] -> Bit
spongeNonempty _
    | P == 0 => False
    | P != 0 => True

/**
 * Section 2.1.1 of [SPONGE] defines bitstrings considered as a sequence of
 * blocks of some fixed length, denoted `x`, where the final block may have
 * length less than `x`. Section 2.1.2 defines padding a bitstring to a length
 * that is a multiple of `x`. We introduce the following type encoding the
 * length of a padding returned by the "simple" method.
 */
type SimplyPadded L x = x - (L % x)

/**
 * Deal with a verbose type constraint.
 * When `x >= 1`, the following facts are for all naturals `L`.
 */
type constraint ModFact L x = (
      x >= L % x
    , x - L % x >= 1
    , x >= 1
)

/**
 * Definition 2 of Section 2.1.2 of [SPONGE] defines simple padding.
 * Here, `x` is the block length, and `L` is the length of the message.
 * `p` is the length of padding derived from `x` and `L`.
 *
 * Note that there is no dependence on the message.
 */
simplePadding: {x, L} (fin x, fin L, ModFact L x) => [SimplyPadded L x]
simplePadding = [True] # zero

/**
 * Section 2.1.1 of [SPONGE] defines bitstrings considered as a sequence of
 * blocks of some fixed length, denoted `x`, where the final block may have
 * length less than `x`. Section 2.1.2 defines padding a bitstring to a length
 * that is a multiple of `x`. We introduce the following type encoding the
 * length of a padded bitstring computed by the "multi-rate" method.
 */
type MultiRatePadded L x = x - (L % x) + 1

/**
 * Definition 3 of Section 2.1.2 of [SPONGE] defines multi-rate padding.
 * `x` and `L` are defined as in simple padding.
 *
 * Note that there is no dependence on the message.
 */
multiratePadding: {x, L} (fin x, x >= 1, fin L) => [MultiRatePadded L x]
multiratePadding = [True] # zero # [True]

/**
 * Assert that simple padding is a sponge compliant padding rule
 * for any non-zero block size `x`.
 *
 * ```
 * :prove simplePaddingCompliance `{8, 8, 2}
 * ```
 */
simplePaddingCompliance:
    {L, L', x} (fin L, fin L', fin x, ModFact L x, ModFact L' x) =>
    [L] -> [L'] -> Bit
property simplePaddingCompliance M M' = b1 && spongeInequalityCondition p p' M M'
    where
        p = simplePadding `{x, L}
        p' = simplePadding `{x, L'}
        b1 = spongeNonempty p && spongeNonempty p'

/**
 * Assert that multi-rate padding is a sponge compliant padding rule
 * for any non-zero block size `x`.
 */
multiratePaddingCompliance:
    {L, L', x} (fin L, fin L', fin x, x >= 1) =>
    [L] -> [L'] -> Bit
property multiratePaddingCompliance M M' = b1 && spongeInequalityCondition p p' M M'
    where
        p = multiratePadding `{x, L}
        p' = multiratePadding `{x, L'}
        b1 = spongeNonempty p && spongeNonempty p'