/**
 * The sponge construction is a method of instantiating a function with
 * arbitrary output length based upon a fixed-length transformation,
 * such as a hash function. The sponge construction was famously used
 * in the design of Keccak and SHA-3.
 *
 * The sponge construction in its generic form is interesting in its
 * right. This module implements the sponge construction as a
 * parameterized module.
 *
 * References:
 * [SPONGE]
 *    Cryptographic Sponge Functions (Version 0.1)
 *    Bertoni, Daemen, Peeters, Van Assche
 *    January 14, 2011
 *    @see https://keccak.team/files/CSF-0.1.pdf
 *
 * @copyright Galois, Inc.
 * @author John Christensen <jchristensen@galois.com>
 *
 */

module Primitive::Keyless::Sponge::Specification where

parameter
    /**
     * The sponge construction is based on a fixed-length transformation.
     * Optionally, this transformation is a permutation. The fixed length
     * of the transformation is called the width of the transformation,
     * and is denoted by `b` in Section 1.2 of [SPONGE].
     *
     * `b` is a number of bits.
     */
    type b: #

    /**
     * The sponge construction requires a value `r`, called the bitrate.
     * This term is first used in Section 1.2 of [SPONGE].
     */
    type r: #

    /**
     * The sponge construction requires a value `c`, called the capacity.
     * This term is first used in Section 1.2 of [SPONGE].
     */
    type c: #

    /**
     * The sponge construction operates on a state of `b` bits.
     * In Section 1.2 of [SPONGE], it is defined that `b = r + c`.
     */
    type constraint (b == r + c)

    /**
     * The `absorb` function expects the input to be in blocks
     * of size `r`. Both the `absorb` and `squeeze` functions
     * require `r < b`.
     */
    type constraint (fin r, r >= 1, r < b)

    /**
     * The sponge construction is based on a fixed-length transformation.
     * The particular transformation is called `f` in Section 1.2 of [SPONGE].
     */
    f : [b] -> [b]

    /**
     * The sponge construction requires a padding function that
     * takes the length of the message in bits (`L`) and some block length (`x`)
     * and returns a bitstring. The padding function must return a number of
     * bits that is fully determined by these two parameters, according to
     * Section 2.1.2.
     */
    pad : {L, x, P} (fin L, fin P, fin x, x > 0, (L + P) % x == 0) => [P]


/**
 * Condense a verbose type constraint.
 */
type constraint Fin A B C D = (fin A, fin B, fin C, fin D)

/**
 * A padding rule used in the sponge construction must be sponge compliant.
 * This notion is defined in Section 2.1.2 Definition 1 of [SPONGE], and
 * is partially modeled here as a property of the specification.
 * Specifically, this models compliance with the formula 2.1
 * of Definition 1.
 *
 * Here, `L` and `L'` represent the lengths of the messages in bits.
 * `P` and `P'` represent the length of the padding returned by the padding
 * function. We may replace the actual padding function with its output
 * in this property without loss of soundness because Section 2.1.2 states
 * that padding rules compliant with the sponge construction must be fully
 * determined from the message length and the block length.
 */
spongeInequalityCondition:
    {L, L', P, P'} (Fin L L' P P') =>
    [P] -> [P'] -> [L] -> [L'] -> Bit
spongeInequalityCondition p p' M M'
    | (L == L', P >= P') => M != M' ==> (M # p) != (M' # p' # zero)
    | (L == L', P <  P') => M != M' ==> (M' # p') != (M # p # zero)
    | (L + P >= L' + P') => (M # p) != (M' # p' # zero)
    | (L + P <  L' + P') => (M' # p') != (M # p # zero)

/**
 * A sponge compliant padding rule must not return the empty bitstring
 * for any message.
 */
spongeNonempty: {P} () => [P] -> Bit
spongeNonempty _
    | P == 0 => False
    | P != 0 => True

/**
 * Section 2.1.1 of [SPONGE] defines bitstrings considered as a sequence of
 * blocks of some fixed length, denoted `x`, where the final block may have
 * length less than `x`. Section 2.1.2 defines padding a bitstring to a length
 * that is a multiple of `x`. We introduce the following type encoding the
 * length of a padding returned by the "simple" method.
 */
type SimplyPadded L x = x - (L % x)

/**
 * Deal with a verbose type constraint.
 * When `x >= 1`, the following facts are for all naturals `L`.
 */
type constraint ModFact L x = (
      x >= L % x
    , x - L % x >= 1
    , x >= 1
)

/**
 * Definition 2 of Section 2.1.2 of [SPONGE] defines simple padding.
 * Here, `x` is the block length, and `L` is the length of the message.
 * `p` is the length of padding derived from `x` and `L`.
 *
 * Note that there is no dependence on the message.
 */
simplePadding: {x, L} (fin x, fin L, ModFact L x) => [SimplyPadded L x]
simplePadding = [True] # zero

/**
 * Section 2.1.1 of [SPONGE] defines bitstrings considered as a sequence of
 * blocks of some fixed length, denoted `x`, where the final block may have
 * length less than `x`. Section 2.1.2 defines padding a bitstring to a length
 * that is a multiple of `x`. We introduce the following type encoding the
 * length of a padded bitstring computed by the "multi-rate" method.
 */
type MultiRatePadded L x = x - (L % x) + 1

/**
 * Definition 3 of Section 2.1.2 of [SPONGE] defines multi-rate padding.
 * `x` and `L` are defined as in simple padding.
 *
 * Note that there is no dependence on the message.
 */
multiratePadding: {x, L} (fin x, x >= 1, fin L) => [MultiRatePadded L x]
multiratePadding = [True] # zero # [True]

/**
 * Assert that simple padding is a sponge compliant padding rule
 * for any non-zero block size `x`.
 *
 * ```
 * :prove simplePaddingCompliance `{8, 8, 2}
 * ```
 */
simplePaddingCompliance:
    {L, L', x} (fin L, fin L', fin x, ModFact L x, ModFact L' x) =>
    [L] -> [L'] -> Bit
property simplePaddingCompliance M M' = b1 && spongeInequalityCondition p p' M M'
    where
        p = simplePadding `{x, L}
        p' = simplePadding `{x, L'}
        b1 = spongeNonempty p && spongeNonempty p'

/**
 * Assert that multi-rate padding is a sponge compliant padding rule
 * for any non-zero block size `x`.
 */
multiratePaddingCompliance:
    {L, L', x} (fin L, fin L', fin x, x >= 1) =>
    [L] -> [L'] -> Bit
property multiratePaddingCompliance M M' = b1 && spongeInequalityCondition p p' M M'
    where
        p = multiratePadding `{x, L}
        p' = multiratePadding `{x, L'}
        b1 = spongeNonempty p && spongeNonempty p'

/**
 * The absorbing function `r` bit input blocks and XORs them into
 * the first `r` bits of an initial state. This operation is interleaved with
 * the application of the transformation `f`. At the end of the absorption
 * function, the state is returned.
 */
absorb: {n} (fin n) => [n*r] -> [b]
absorb P = foldl absorb_f_r s_init (split `{n} P)
    where
        // The initial state is a bitstring of length `b`.
        s_init = zero `{[b]}
        // Each block `p` is length `r`.
        // To XOR with a state of length `b`, we must pad `p`
        // by `b - r`.
        zb = zero `{[b - r]}
        // The following function is iterated over the blocks
        // of `P`.
        absorb_f_r = \s p -> f (s ^ p # zb)

/**
 * The squeezing function iteratively returns the first `r` bits of state
 * interleaved with applications of the transformation `f` a number of times
 * determined by the caller.
 */
squeeze: {l} () => [b] -> [l]
squeeze s = Zl
    where
        // Iterate `f` over `s`, taking the first `r` bits of each iterate.
        Zs = map (take `{r}) (iterate f s)
        // Treat the whole list as a bitstring, and take the first `l` bits.
        Zl = take (join Zs)

/**
 * The sponge construction is the subsequent application of the padding rule,
 * the aborbing function, and the squeezing function.
 */
sponge: {l, n, p, z} (fin n, fin p, n+p % r == 0, z == (n + p) / r) => [n] -> [l]
sponge M = Z
    where
        P = M # pad `{n, r, p}
        s = absorb `{z} P
        Z = squeeze `{l} s
