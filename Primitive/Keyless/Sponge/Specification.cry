/**
 * The sponge construction is a method of instantiating a function with
 * arbitrary output length based upon a fixed-length transformation,
 * such as a hash function. The sponge construction was famously used
 * in the design of Keccak and SHA-3.
 *
 * The sponge construction in its generic form is interesting in its
 * right. This module implements the sponge construction as a
 * parameterized module.
 *
 * References:
 * [SPONGE]
 *    Cryptographic Sponge Functions (Version 0.1)
 *    Bertoni, Daemen, Peeters, Van Assche
 *    January 14, 2011
 *    @see https://keccak.team/files/CSF-0.1.pdf
 *
 * @copyright Galois, Inc.
 * @author John Christensen <jchristensen@galois.com>
 *
 */

module Primitive::Keyless::Sponge::Specification where

parameter
    /**
     * The sponge construction is based on a fixed-length transformation.
     * Optionally, this transformation is a permutation. The fixed length
     * of the transformation is called the width of the transformation,
     * and is denoted by `b` in Section 1.2 of [SPONGE].
     *
     * `b` is a number of bits.
     */
    type b: #

    /**
     * The sponge construction requires a value `r`, called the bitrate.
     * This term is first used in Section 1.2 of [SPONGE].
     */
    type r: #

    /**
     * The sponge construction requires a value `c`, called the capacity.
     * This term is first used in Section 1.2 of [SPONGE].
     */
    type c: #

    /**
     * The sponge construction operates on a state of `b` bits.
     * In Section 1.2 of [SPONGE], it is defined that `b = r + c`.
     */
    type constraint (b == r + c)

    /**
     * The `absorb` function expects the input to be in blocks
     * of size `r`. Both the `absorb` and `squeeze` functions
     * require `r < b`.
     */
    type constraint (fin r, r >= 1, r < b)

    /**
     * The sponge construction is based on a fixed-length transformation.
     * The particular transformation is called `f` in Section 1.2 of [SPONGE].
     */
    f : [b] -> [b]

    /**
     * The sponge construction requires a padding function that
     * takes the length of the message in bits (`L`) and some block length (`x`)
     * and returns a bitstring. The padding function must return a number of
     * bits that is fully determined by these two parameters, according to
     * Section 2.1.2.
     */
    pad : {L, x, P} (fin L, fin P, P > 0, fin x, x > 0, (L + P) % x == 0) => [P]


/**
 * The absorbing function `r` bit input blocks and XORs them into
 * the first `r` bits of an initial state. This operation is interleaved with
 * the application of the transformation `f`. At the end of the absorption
 * function, the state is returned.
 *
 * See [SPONGE] 2.4.1 Algorithm 3.
 *
 * The type parameter `Pr` is the number of length `r` blocks in `P`.
 * It is meant to evoke the notation `|P|_r` in the specification.
 */
absorb: {Pr} (fin Pr) => [Pr*r] -> [b]
absorb P = foldl absorb_f_r s_init (split `{Pr} P)
    where
        // The initial state is a bitstring of length `b`.
        s_init = zero `{[b]}
        // Each block `p` is length `r`.
        // To XOR with a state of length `b`, we must pad `p`
        // by `b - r`.
        zb = zero `{[b - r]}
        // The following function is iterated over the blocks
        // of `P`.
        absorb_f_r = \s p -> f (s ^ p # zb)

/**
 * The squeezing function iteratively returns the first `r` bits of state
 * interleaved with applications of the transformation `f` a number of times
 * determined by the caller.
 *
 * See [SPONGE] 2.4.2 Algorithm 4.
 */
squeeze: {l} () => [b] -> [l]
squeeze s = Zl
    where
        // Iterate `f` over `s`, taking the first `r` bits of each iterate.
        Zs = map (take `{r}) (iterate f s)
        // Treat the whole list as a bitstring, and take the first `l` bits.
        Zl = take (join Zs)

/**
 * The sponge construction is the subsequent application of the padding rule,
 * the aborbing function, and the squeezing function.
 *
 * See [SPONGE] 2.5 Formula 2.4 and 2.2/2.3 Algorithm 1
 *
 * `l` is the number of bits that should be "squeezed" from the sponge.
 * `n` is the length of the message...the letter `n` was chosen arbitrarily.
 * `p` is the length of the padding produced by the `pad` function. It does not
 *   appear in the specification, but is present to satisfy Cryptol's
 *   typechecker.
 * `Pr` is the number of length `r` blocks in the padded message.
 *    It's name is chosen in symmetry with `absorb`s parameter `Pr`.
 */
sponge: {l, n, p, Pr} (fin n, fin p, p > 0, n+p % r == 0, Pr == (n + p) / r) => [n] -> [l]
sponge M = Z
    where
        P = M # pad `{n, r, p}
        s = absorb `{Pr} P
        Z = squeeze `{l} s
