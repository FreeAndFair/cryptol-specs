/**
 * The sponge construction is a method of instantiating a function with
 * arbitrary output length based upon a fixed-length transformation,
 * such as a hash function. The sponge construction was famously used
 * in the design of Keccak and SHA-3.
 *
 * The sponge construction in its generic form is interesting in its
 * right. This module implements the sponge construction as a
 * parameterized module.
 *
 * References:
 * [SPONGE]
 *    Cryptographic Sponge Functions (Version 0.1)
 *    Bertoni, Daemen, Peeters, Van Assche
 *    January 14, 2011
 *    @see https://keccak.team/files/CSF-0.1.pdf
 *
 * @copyright Galois, Inc.
 * @author John Christensen <jchristensen@galois.com>
 *
 */

module Primitive::Keyless::Sponge::Specification where

import Primitive::Keyless::Sponge::Padding as Padding

parameter
    /**
     * The sponge construction is based on a fixed-length transformation.
     * Optionally, this transformation is a permutation. The fixed length
     * of the transformation is called the width of the transformation,
     * and is denoted by `b` in Section 1.2 of [SPONGE].
     *
     * `b` is a number of bits.
     */
    type b: #

    /**
     * The sponge construction requires a value `r`, called the bitrate.
     * This term is first used in Section 1.2 of [SPONGE].
     */
    type r: #

    /**
     * The `absorb` function expects the input to be in blocks
     * of size `r`. Both the `absorb` and `squeeze` functions
     * require `r < b`.
     */
    type constraint (fin r, r >= 1, r < b)

    /**
     * The sponge construction requires a value `c`, called the capacity.
     * This term is first used in Section 1.2 of [SPONGE].
     *
     * `c` is not used in the definition of the sponge, but is
     * important for the security analysis of different sponge
     * constructions.
     */
    type c = b - r

    /**
     * The sponge construction operates on a state of `b` bits.
     * In Section 1.2 of [SPONGE], it is defined that `b = r + c`.
     */
    type constraint (b == r + c)

    /**
     * The sponge construction is based on a fixed-length transformation.
     * The particular transformation is called `f` in Section 1.2 of [SPONGE].
     */
    f : [b] -> [b]

    /**
     * Cryptol does not allow parameterized constraints or "arrow" types...
     * types that take other types as parameters. Cryptol needs to statically
     * determine the types of all functions, in particular, the lengths of
     * sequences. This makes it difficult to generalize the padding function.
     *
     * We restrict to padding functions of the following form:
     * - add some fixed number of bits, `PaddingType`, to the message.
     * - Pad the length out to the next multiple of the block size.
     *
     * This excludes many valid padding rules, but admits the two padding
     * rules described in [SPONGE] (simple and multirate padding).
     *
     * In fact, we simply restrict to these two rules.
     */
    type PaddingType: #

    /**
     * Allow only values for `PaddingType` described in [SPONGE].
     */
    type constraint (1 <= PaddingType, PaddingType <= 2)

    /**
     * Describe the length of the padding for a given
     * message length `L`, block length `r`, and number of
     * fixed bits `PaddingType`.
     */
    type PadLength L x = x * ((L + PaddingType) /^ x) - L

    /**
    * Constraints for the padding function.
    * The input length `L` must be finite..
    * The fixed block length `x` must be finite and greater than `0`.
    * The end result must be a multiple of `x` and length greater than `0`,
    * but we do not enforce that here.
    */
    type constraint PadConstraint L x = (
        fin L, fin x, x > 0
        )

/**
 * The sponge construction is the subsequent application of the padding rule,
 * the aborbing function, and the squeezing function.
 *
 * See [SPONGE] 2.5 Formula 2.4 and 2.2/2.3 Algorithm 1
 *
 * `l` is the number of bits that should be "squeezed" from the sponge.
 * `m` is the length of the message...the letter `m` was chosen arbitrarily.
 *
 * [SPONGE] Algorithm 4 requires `l > 0`, so this constraint is required
 * is also required here.
 */
sponge:
    {l, m}
    (PadConstraint m r, l > 0)
    => [m] -> [l]
sponge M = Z
    where
        P = M # pad `{m, r}
        s = absorb P
        Z = squeeze `{l} s

private

    /**
     * Cryptol's type system disallows comparing sequences that have different
     * lengths. The padding compliance criterion allows sequences of different
     * lengths to be compared. Emulate this as follows:
     * - If the sequences have the same types (thereby lengths), use
     *   the built-in comparison.
     * - If the sequences have different types (thereby lengths), they
     *   cannot possibly be equal.
     *
     * ```repl
     * :prove comparisonHelper [True] [False] == False
     * :prove comparisonHelper [True] [True] == True
     * :prove comparisonHelper [True] [True, True] == False
     * ```
     */
    comparisonHelper :
        {L1, L2, a} (fin L1, fin L2, Eq a)
        => [L1]a -> [L2]a -> Bit
    comparisonHelper x y
        | L1 == L2 => x == y
        | L1 != L2 => False

    /**
     * A padding rule is sponge compliant if it never returns the empty string
     * and satisfies an "injectivity" criterion described in [SPONGE]
     * Section 2.1.2 formula 2.1. The injectivity criterion is encoded
     * here.
     *
     * Here, `M` and `M'` are chosen from `Z_2^*`, the set of all bitstrings with
     * finite length. `Ml` and `Ml'` are the lengths of `M` and `M'` respectively.
     * `Pl` and `Pl'` is the length of padding returned by the function `pad` for
     * the given length and the fixed block length `x`.
     *
     * The property states for all `n >= 0`, if `M != M'`, then, abusing notation
     * `M # <pad for M> != M' # <pad for M'> # zeros`
     */
    padCompliant :
        {Ml, Ml', x, n}
        (PadConstraint Ml x, PadConstraint Ml' x, fin n)
        => [Ml] -> [Ml'] -> Bit
    property padCompliant M M' = ~comparisonHelper M M' ==> ~comparisonHelper Mp Mp'
        where
            Mp = M # pad `{Ml, x}
            Mp' = M' # pad `{Ml', x} # zn
            zn = zero `{[n * r]}

    /**
     * A padding rule is sponge compliant if it never returns the empty string
     * and satisfies an "injectivity" criterion described in [SPONGE]. The
     * non-emptiness criterion is encoded here.
     *
     * The padding length is determined by the message length and block length
     * alone. Thus, no explicit messages are required to verify the property.
     */
    padNonempty :
        {M, x}
        (PadConstraint M x)
        => Bit
    property padNonempty = `(PadLength M x) != 0

    /**
     * The absorbing function `r` bit input blocks and XORs them into
     * the first `r` bits of an initial state. This operation is interleaved with
     * the application of the transformation `f`. At the end of the absorption
     * function, the state is returned.
     *
     * See [SPONGE] 2.4.1 Algorithm 3.
     *
     * The type parameter `Pr` is the number of length `r` blocks in `P`.
     * It is meant to evoke the notation `|P|_r` in the specification.
     */
    absorb: {Pr} (fin Pr) => [Pr*r] -> [b]
    absorb P = foldl absorb_f_r s_init (split `{Pr} P)
        where
            // The initial state is a bitstring of length `b`.
            s_init = zero `{[b]}
            // Each block `p` is length `r`.
            // To XOR with a state of length `b`, we must pad `p`
            // by `b - r`.
            zb = zero `{[b - r]}
            // The following function is iterated over the blocks
            // of `P`.
            absorb_f_r = \s p -> f (s ^ p # zb)

    /**
     * The squeezing function iteratively returns the first `r` bits of state
     * interleaved with applications of the transformation `f` a number of times
     * determined by the caller.
     *
     * See [SPONGE] 2.4.2 Algorithm 4.
     */
    squeeze: {l} (l > 0) => [b] -> [l]
    squeeze s = Zl
        where
            // Iterate `f` over `s`,
            // taking the first `r` bits of each iterate.
            Zs = map (take `{r}) (iterate f s)
            // Treat the whole list as a bitstring,
            // and take the first `l` bits.
            Zl = take (join Zs)

    /**
     * The sponge construction requires a padding function that
     * takes the length of the message in bits (`L`) and some block length (`x`)
     * and returns a bitstring. The padding function must return a number of
     * bits that is fully determined by these two parameters, according to
     * Section 2.1.2.
     *
     * In general, many lengths should be permissable. For the purposes of this
     * specification, we restrict to a very special class of output lengths.
     * Not only that, but we also restrict to two specific implementations.
     */
    pad : {L, x} (PadConstraint L x) => [PadLength L x]
    pad | PaddingType == 1 => Padding::simplePadding `{L, x}
        | PaddingType == 2 => Padding::multiratePadding `{L, x}
