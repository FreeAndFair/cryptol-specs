/**
 * Specification of the Keccak (SHA-3) hash function.
 *
 *
 *
 * [FIPS-202]: National Institute of Standards and Technology. SHA-3 Standard:
 *     Permutation-Based Hash and Extendable-Output Functions. (Department of
 *     Commerce, Washington, D.C.), Federal Information Processing Standards
 *     Publication (FIPS) NIST FIPS 202. August 2015.
 *     @see https://dx.doi.org/10.6028/NIST.FIPS.202
 *
 * @copyright Galois, Inc. 2013 - 2024
 * @author David Lazar <lazard@galois.com>
 * @author Marcella Hastings <marcella@galois.com>
 *
 */
module Primitive::Keyless::Hash::keccak where

parameter
    /**
     * Width: the fixed length of the strings that are permuted.
     *
     * This restricts `b` to the valid permutation widths:
     * 25, 50, 100, 200, 400, 800, and 1600.
     * In particular, the final constraint enforces that `b / 25` is exactly a
     * power of two, so 0 and any other multiple of 25 are invalid.
     *
     * [FIPS-202] Section 3 (intro).
     */
    type b : #
    type constraint (fin b, b % 25 == 0, b <= 1600, (2 ^^ (lg2 (b / 25))) * 25 == b)

    /**
     * Rounds: the number of iterations of an internal transformation.
     *
     * [FIPS-202] Section 3 (intro).
     */
    type nr : #
    type constraint (fin nr, nr > 0, nr == 12 + 2 * (lg2 ( b / 25)))

Keccak : {r, m}
    ( fin r, fin m, b >= r, r >= 1) => [m] -> [inf]
Keccak M = extend (Ss ! 0) where
    // Step 1.
    P = M # pad `{x = r, m = m}
    // Step 2. We leave the type `n` implicit.
    // Step k3.
    type c = b - r
    // Step 4. Ps = P_0, ..., P_{n-1}.
    Ps = split P : [_][r]
    // Step 5.
    S = zero : [b]
    // Step 6. We create a list `Ss` instead of overwriting the variable `S`.
    Ss = [S] # [Keccak_f (S' ^ (Pi # (zero : [c]))) | Pi <- Ps | S' <- Ss]
    // Step 7 - 9. This step is sometimes known as "squeeze".
    extend : [b] -> [inf]
    extend Z = (take`{r} Z) # extend (Keccak_f Z)

private
    /**
     * State width of the permutation.
     * [FIPS-202] Section 3.1.
     */
    type w = b / 25

    /**
     * TODO: Figure out what this represents for the docs.
     * [FIPS-202] Section 3.1.
     */
    type ell = lg2 w
    type State = [5][5][w]

    /**
     * Padding rule `pad10*1`.
     *
     * This function produces padding e.g. a string with an appropriate length
     * to append to another string.
     * [FIPS-202] Section 5.1.
     *
     * TODO: add notes about j equivalence and why the return type here makes sense.
     */
    pad : {x, m} (fin x, fin m, x >= 1) => [x * ((m + 2) /^ x) - m]
    pad = [1] # zero # [1]

    /**
     * One of the step mappings that's part of a round of Keccak-p.
     *
     * [FIPS-202] Section 3.2.1.
     */
    θ : State -> State
    θ A = A' where
        C = [ xor a | a <- A ]
        D = [ C @ x ^ (C @ y <<< 1)
            // In the spec, this is denoted `(x-1) mod 5` for 0 <= x < 5.
            | (x:[8]) <- [4,0,1,2,3]
            // In the spec, this is denoted `(x+1) mod 5` for 0 <= x < 5.
            | (y:[8]) <- [1,2,3,4,0]
            ]
        A' = [ [ a ^ (D @ x) | a <- A @ x ] | (x:[8]) <- [0 .. 4] ]

    /**
     * One of the step mappings that's part of a round of Keccak-p.
     *
     * [FIPS-202] Section 3.2.2.
     */
    ρ : State -> State
    ρ A = groupBy`{5} [ a <<< r | a <- join A | (r:[8]) <- R ]
        where
            R = [
                00, 36, 03, 41, 18,
                01, 44, 10, 45, 02,
                62, 06, 43, 15, 61,
                28, 55, 25, 21, 56,
                27, 20, 39, 08, 14
            ]

    /**
     * One of the step mappings that's part of a round of Keccak-p.
     *
     * [FIPS-202] Section 3.2.3.
     */
    π : State -> State
    π A = groupBy`{5} [ A @ ((x + 3*y) % 5) @ x
                    | (x:[8]) <- [0..4], (y:[8]) <- [0..4]
                    ]

    /**
     * One of the step mappings that's part of a round of Keccak-p.
     *
     * [FIPS-202] Section 3.2.4.
     */
    χ : State -> State
    χ A = groupBy`{5} [ (A @ x @ y) ^ (~ A @ ((x + 1) % 5) @ y
                                    && A @ ((x + 2) % 5) @ y)
                    | (x:[8]) <- [0..4], (y:[8]) <- [0..4]
                    ]

    /**
     * One of the step mappings that's part of a round of Keccak-p.
     *
     * [FIPS-202] Section 3.2.5.
     */
    ι : State -> State -> State
    ι RC A = A ^ RC

    RCs : {n} (fin n, 24 >= n, n == 12 + 2 * ell) => [n]State
    RCs = take`{n} [ [[take`{w} RC] # zero] # zero | RC <- RCs64 ]

    RCs64 : [24][64]
    RCs64 = join (transpose [
        [0x0000000000000001, 0x000000008000808B],
        [0x0000000000008082, 0x800000000000008B],
        [0x800000000000808A, 0x8000000000008089],
        [0x8000000080008000, 0x8000000000008003],
        [0x000000000000808B, 0x8000000000008002],
        [0x0000000080000001, 0x8000000000000080],
        [0x8000000080008081, 0x000000000000800A],
        [0x8000000000008009, 0x800000008000000A],
        [0x000000000000008A, 0x8000000080008081],
        [0x0000000000000088, 0x8000000000008080],
        [0x0000000080008009, 0x0000000080000001],
        [0x000000008000000A, 0x8000000080008008]
    ])

    /**
     * Keccak-f family of permutations.
     *
     * [FIPS-202] Section 3.4.
     */
    Keccak_f : [b] -> [b]
    Keccak_f S = S'
        where
            A0 = unflatten S
            rounds = [A0] # [ Round RC A | RC <- RCs | A <- rounds ]
            S' = flatten (rounds ! 0)


    Round : State -> State -> State
    Round RC A = ι RC (χ (π (ρ (θ A))))

    unflatten : {r} (b >= r) => [r] -> State
    unflatten p = transpose (groupBy`{5} (reverse (groupBy`{w} (reverse (p # zero)))))

    flatten : State -> [5 * 5 * w]
    flatten A = reverse (join (reverse (join (transpose A))))

    xor : {a, c} (fin a) => [a][c] -> [c]
    xor xs = xors ! 0
        where xors = [zero] # [ x ^ z | x <- xs | z <- xors ]

    lfsr : [inf]
    lfsr = [ p!0 | p <- ps ]
        where
        /* powers of x modulo m */
        ps = [0x01] # [ pmod (pmult p 0b10) m | p <- ps ]
        m = <| x^^8 + x^^6 + x^^5 + x^^4 + 1 |>

property RC_correct i j =
    (i:[8]) < 24 ==> (j:[8]) < 7 ==> RCs64@i!(2^^j - 1) == lfsr@(j + 7*i)

/**
 * See https://keccak.team/files/Keccak-reference-3.0.pdf, Section 1.2
 * ```repl
 * :prove unflatten_correct`{n=1600}
 * ```
 * TODO: These hardcoded 64s are wrong when `n =/= 1600`.
 */
unflatten_correct : {n} (fin n, b >= n) => [12] -> [12] -> [12] -> [n] -> Bit
property unflatten_correct x y z p =
    x < 5 ==> y < 5 ==> z < (64:[12]) ==>
    p@((5*y + x)*64 + z) == unflatten p @ x @ y ! z

/**
 * ```repl
 * :prove flatten_correct
 * ```
 */
property flatten_correct s =
    unflatten (flatten s) == s


