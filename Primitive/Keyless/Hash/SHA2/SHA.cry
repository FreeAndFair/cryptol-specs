/*
Copyright (c) 2018, Galois Inc.
www.cryptol.net

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

module Primitive::Keyless::Hash::SHA2::SHA where

import Array
import Common::ByteArray

sha : {L} (2 * w >= width L) => [L] -> [digest_size]
sha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))

parameter

  /** Word size
    Specifications are based on word size w, rather than digest size (8 * w)
    or block size (m == 16 * w), in order to avoid confusing Cryptol's type
    constraint verifier with integer division.
  */

  type wp : #
  type constraint (fin wp, wp >= 32, 64 >= wp)

  type digest_size : #
  type constraint (fin digest_size, 8*wp >= digest_size)

  /** The number of iterations in the hash computation
  (i.e. the number of words in K) */

  type j : #
  type constraint (fin j, j >= 17)

  H0 : [8][wp]
  K  : [j][wp]

  /* FIPS 180-4 defines lowercase and uppercase
      (respective to the Greek alphabet) sigma functions for SHA-256 and SHA-512.
      (4.4)-(4.7) SHA-224, SHA-256 (w==32)
      (4.10)-(4.13) SHA-384, SHA-512, SHA-512/224, SHA-512/256 (w==64) */

  SIGMA_0 : [wp] -> [wp]
  SIGMA_1 : [wp] -> [wp]
  sigma_0 : [wp] -> [wp]
  sigma_1 : [wp] -> [wp]

private
  type w = wp

  /** block size corresponding to word size for all SHA algorithms in
      FIPS 180-4 */
  type block_size = 16 * w

  type num_blocks L     = (L+1+2*w) /^ block_size
  type padded_size L    = num_blocks L * block_size


  /** (4.1) (w==32), (4.2) (w==32), (4.8) (w==64) */
  Ch : [w] -> [w] -> [w] -> [w]
  Ch x y z = (x && y) ^ (~x && z)


  /** (4.1) (w==32), (4.3) (w==32), (4.9) (w==64) */
  Maj : [w] -> [w] -> [w] -> [w]
  Maj x y z = (x && y) ^ (x && z) ^ (y && z)


  /**
    5.1 Padding the Message
    5.1.1 SHA-1, SHA-224 and SHA-256 (w==32)
    5.1.2 SHA-384, SHA-512, SHA-512/224 and SHA-512/256 (w==64)

  The constraint ensure that the message size, `L`, fits within a
  (2 * w)-bit word (consistent w/ Figure 1)
  */
  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]
  pad M = M # 0b1 # zero # (`L : [2*w])

  /**
    5.2 Parsing the Message
    5.2.1 SHA-1, SHA-224 and SHA-256 (w==32)
    5.2.2 SHA-384, SHA-512, SHA-512/224 and SHA-512/256 (w==64)
  */
  parse : {m} [m * block_size] -> [m][block_size]
  parse = split

  type SHAState_Array =
    { h : [8][w]
    , block : ByteArray
    , n : [32]
    , sz : [w * 2]
    }

SHAH0 = H0
S0 = SIGMA_0
S1 = SIGMA_1
s0 = sigma_0
s1 = sigma_1

/**
SHA-256 and SHA-512 (and their respective derivatives) use a similar
message schedule that can be expressed in the same way relative to their
respective sigma functions.

  6.2.2 SHA-256 Hash Computation (w==32, j=64)
  6.4.2 SHA-512 Hash Computation (w==64, j=80)
*/
messageSchedule_Common : [16][w] -> [j][w]
messageSchedule_Common Mi = take W
  where
  W : [inf][_]
  W = Mi # [ w1 + s0 w2 + w3 + s1 w4
           | w1 <- W
           | w2 <- drop`{1} W
           | w3 <- drop`{9} W
           | w4 <- drop`{14} W
           ]


/**
Amazon S2N's SHA-256 specification includes a compression routine intended
to reflect typical implementations.  This same compression routine applies
to SHA-512, modulo respective constants, sigma functions,
and message schedules.
*/


compress_Common : [8][w] -> [j][w] -> [8][w]
compress_Common H W =
  // XXX: This whole definitions looks like it might be simplifiable.
  [ (as ! 0) + (H @ 0),
    (bs ! 0) + (H @ 1),
    (cs ! 0) + (H @ 2),
    (ds ! 0) + (H @ 3),
    (es ! 0) + (H @ 4),
    (fs ! 0) + (H @ 5),
    (gs ! 0) + (H @ 6),
    (hs ! 0) + (H @ 7)
  ]
  where
    T1 = [h + S1 e + Ch e f g + k_t + w_t
              | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]
    T2 = [ S0 a + Maj a b c | a <- as | b <- bs | c <- cs]
    hs = take`{j + 1}([H @ 7] # gs)
    gs = take`{j + 1}([H @ 6] # fs)
    fs = take`{j + 1}([H @ 5] # es)
    es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])
    ds = take`{j + 1}([H @ 3] # cs)
    cs = take`{j + 1}([H @ 2] # bs)
    bs = take`{j + 1}([H @ 1] # as)
    as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])

processBlock_Common : [8][w] -> [16][w] -> [8][w]
processBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)


SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]
SHA_2_Common' blocks = hash ! 0
  where
  hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]

///////////////////////////////////////////////////////////////////////////////
// SHA imperative specification - SMT Array
///////////////////////////////////////////////////////////////////////////////

SHAInit_Array : SHAState_Array
SHAInit_Array =
  { h = H0
  , block = arrayConstant 0
  , n = 0
  , sz = 0
  }

SHAUpdate_Array : SHAState_Array -> ByteArray -> [64] -> SHAState_Array
SHAUpdate_Array state data len =
  if state.n != 0
    then if len < 2 * `w - n
      then state'
      else state''
    else state'''
 where
   n = 0 # state.n
   state' = { h = state.h, block = block', n = drop n', sz = state.sz + (0 # len) * 8 }
    where
      block' = arrayCopy state.block n data 0 len
      n' = n + len
   state'' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }
    where
      h' = processBlock state.h (arrayCopy state.block n data 0 (2 * `w - n)) 0
      block' = arrayCopy state.block n data 0 (2 * `w - n)
      index' = 2 * `w - n
      len' = len - (2 * `w - n)
      (h'', index'', len'') = if len' >= 2 * `w
        then
          ( (processBlocks h' (arrayCopy (arrayConstant 0) 0 data index' ((len' / (2 * `w)) * (2 * `w))) 0 (len' / (2 * `w)))
          , index' + len' - (len' % (2 * `w))
          , len' % (2 * `w)
          )
        else (h', index', len')
      (block''', n''') = if len'' != 0
        then ((arrayCopy block' 0 data index'' len''), len'')
        else (block', 0)
   state''' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }
    where
      (h'', index'', len'') = if len >= 2 * `w
        then
          ( (processBlocks state.h data 0 (len / (2 * `w)))
          , len - (len % (2 * `w))
          , len % (2 * `w)
          )
        else (state.h, 0, len)
      (block''', n''') = if len'' != 0
        then ((arrayCopy state.block 0 data index'' len''), len'')
        else (state.block, n)

SHAFinal_Array : SHAState_Array -> [digest_size]
SHAFinal_Array state = take (join h''')
  where
    n = 0 # state.n
    block' = arrayUpdate state.block n 0x80
    n' = n + 1
    (h'', block'', n'') = if n' > 2 * `w - `w / 4
      then ((processBlock state.h (arraySet block' n' 0 (2 * `w - n')) 0), (arraySet block' n' 0 (2 * `w - n')), 0)
      else (state.h, block', n')
    h''' = processBlock
      h''
      (arrayRangeUpdate
        (arraySet block'' n'' 0 (2 * `w - `w / 4 - n''))
        (2 * `w - `w / 4)
        (split`{parts=(w+3)/4} (0 # state.sz)))
      0

// Imperative SHA implementation
SHAImp_Array : ByteArray -> [64] -> [digest_size]
SHAImp_Array msg len = SHAFinal_Array (SHAUpdate_Array SHAInit_Array msg len)


processBlocks : [8][w] -> ByteArray -> [64] -> [64] -> [8][w]
processBlocks [a, b, c, d, e, f, g, h] data index n = processBlock [a', b', c', d', e', f', g', h'] data index'
  where
    (a', b', c', d', e', f', g', h', index') = processBlocksLoop n data a b c d e f g h index

processBlock : [8][w] -> ByteArray -> [64] -> [8][w]
processBlock h block index =
  processBlock_Common h (split (join (arrayRangeLookup block index)))

processBlocksLoop : [64] -> ByteArray -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [64] -> ([w], [w], [w], [w], [w], [w], [w], [w], [64])
processBlocksLoop num data a b c d e f g h index = if (index + 2 * `w) < (num * 2 * `w)
  then processBlocksLoop num data a' b' c' d' e' f' g' h' (index + 2 * `w)
  else (a, b, c, d, e, f, g, h, index)
  where
    [a', b', c', d', e', f', g', h'] = (processBlock [a, b, c, d, e, f, g, h] data index)

arrayRangeEqual_arrayRangeLookup_lemma : {n} (fin n, n >= 1, n <= 1000) => ByteArray -> ByteArray -> Bit
arrayRangeEqual_arrayRangeLookup_lemma a b = arrayRangeEqual a 0 b 0 `n == (arrayRangeLookup`{n=n} a 0 == arrayRangeLookup b 0)
