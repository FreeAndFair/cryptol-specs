/*
 * Implementation of the hash algorithms known as SHA1 from [FIPS-180-4].
 *
 * SHA1 is definitively considered to be inferior to other hash functions
 * defined in [FIPS-180-4]. That being said, it is of historical interest
 * and is used in some legacy applications.
 *
 * References
 * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash
 *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal
 *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.
 *     August 2015.
 *     @see https://doi.org/10.6028/NIST.FIPS.180-4
 *
 * @copyright Galois, Inc.
 * @author John Christensen <jchristensen@galois.com>
 * @author Marcella Hastings <marcella@galois.com>
 *
 */

module Primitive::Keyless::Hash::SHA1 where

/**
* `l` is the length of the message in bits.
* For SHA1, `l` < 2 ^^ 64.
*
* References:
* Sections 1, 2.2.1 [FIPS-180-4]
*/
type constraint ValidMessageLength l = (l < 2 ^^ 64)

/**
* `w` is the number of bits in a word.
* The word size for SHA1 is `32`.
*
* References:
* Sections 1, 2.2.1 [FIPS-180-4]
*/
type w = 32

/**
 * `m` is the number of bits in a message block.
 * The block size for SHA1 is `512`.
 */
type m = 512

/**
 * `BlockSize` is a convenient alias for `m`.
 */
type BlockSize = m

/**
 * The message digest size for SHA1 is `160` bits.
 */
type DigestSize = 160

/**
 * Compute SHA1 over a bit string of valid length.
 */
hash: {l} (ValidMessageLength l) => [l] -> [DigestSize]
hash M = sha1 M

/**
 * Many applications have a byte oriented interface to
 * SHA1. Define it for the user's convenience.
 */
hashBytes: {l} (ValidMessageLength (8 * l)) => [l][8] -> [DigestSize / 8][8]
hashBytes M = groupBy`{8} (hash (join M))

private

  /**
   * `ROTL^n` is left rotation by `n`.
   */
  ROTL: {n} (n < w) => [w] -> [w]
  ROTL x = x <<< `n

  /**
   * `Ch` is a function on three words.
   * Its abbreviation is not expanded, however, it
   * could be appropriately called "choose".
   *
   * References:
   * Section 4.1.1 [FIPS-180-4]
   */
  Ch: [w] -> [w] -> [w] -> [w]
  Ch x y z = (x && y) ^ (~x && z)

  /**
   * `Parity` is a function on three words.
   *
   * References:
   * Section 4.1.1 [FIPS-180-4]
   */
  Parity: [w] -> [w] -> [w] -> [w]
  Parity x y z = x ^ y ^ z

  /**
   * `Maj` is a function on three words.
   * Its abbreviation is not expanded, however, it
   * could be appropriately called "majority vote".
   *
   * References:
   * Section 4.1.1 [FIPS-180-4]
   */
  Maj: [w] -> [w] -> [w] -> [w]
  Maj x y z = (x && y) ^ (x && z) ^ (y && z)

  /**
   * SHA1 is composed of `80` functions `f_t`.
   * Each `f_t` is one of the functions `Ch`,
   * `Maj`, or `Parity` depending on `t`.
   *
   * References:
   * Section 4.1.1 [FIPS-180-4]
   */
  f: {t} (t <= 79) => [w] -> [w] -> [w] -> [w]
  f x y z | t <= 19 => Ch x y z
          | t <= 39 => Parity x y z
          | t <= 59 => Maj x y z
          | t <= 79 => Parity x y z

  /**
   * SHA1 uses `80` constants parameterized by `t`.
   *
   * References:
   * Section 4.2.1 [FIPS-180-4]
   */
  K: {t} (t <= 79) => [w]
  K | t <= 19 => 0x5a827999
    | t <= 39 => 0x6ed9eba1
    | t <= 59 => 0x8f1bbcdc
    | t <= 79 => 0xca62c1d6

  /**
    * Number of bits used to encode the length of the message for padding.
    * [FIPS-180-4] Section 5.1. This definition was taken verbatim
    * from the SHA2 cryptol specification.
    */
  type LengthBits = 2 * w

  /**
    * Number of blocks needed to hold the padded version of a message of length L.
    * [FIPS-180-4] Section 5.1. This definition was taken verbatim
    * from the SHA2 cryptol specification.
    */
  type NumBlocks L = (L + 1 + LengthBits) /^ BlockSize

  /**
    * Deterministically pad a message to a multiple of the block size.
    *
    * [FIPS-180-4] Section 5.1.1 and 5.1.2.
    *
    * The constraint is not explicitly noted in Section 5.1, but all
    * messages to be hashed must not exceed the valid message length.
    *
    * This definition was taken verbatim from the SHA2 cryptol specification.
    */
  pad : {L} (ValidMessageLength L) => [L] -> [NumBlocks L * BlockSize]
  pad M = M # 0b1 # zero # (`L : [LengthBits])

  /**
    * The message and its padding must be parsed into `N` blocks.
    * [FIPS-180-4] Section 5.2.
    */
  parse : {N} () => [N * BlockSize] -> [N][BlockSize]
  parse M = split M

  /**
   * Convenience type
   */
  type LetterVars = ([w], [w], [w], [w], [w])

  /**
   * The initial hash value for SHA1 is described in
   * [FIPS-180-4] Section 5.3.1
   */
  H0: LetterVars
  H0 = (  0x67452301
        , 0xefcdab89
        , 0x98badcfe
        , 0x10325476
        , 0xc3d2e1f0
        )

  /**
   * SHA1 preprocessing sets the initial hash value to `H0`.
   * The message is padded and parsed before the hash
   * computation.
   *
   * References:
   * [FIPS-180-4] Section 6.1.1
   */
  sha1_preprocessing: {l} (ValidMessageLength l) => [l] -> [NumBlocks l][BlockSize]
  sha1_preprocessing M = parse (pad M)

  /**
   * Computation of SHA1.
   * The message is padded and parsed.
   * Then each block is mixed with the mixing function, updating the
   * intermdiate hash. When all blocks have been processed, the final
   * state is the hash of the message.
   */
  sha1: {l} (ValidMessageLength l) => [l] -> [DigestSize]
  sha1 M = h0 # h1 # h2 # h3 # h4
    where
      M_t = sha1_preprocessing M
      (h0, h1, h2, h3, h4) = foldl sha1_block H0 M_t

  /**
   * The SHA1 message schedule is recursively defined in terms of the
   * `w` words that make up the message block.
   *
   * References:
   * [FIPS-180-4] Section 6.1.2 Part 1
   */
  message_schedule: [BlockSize] -> [80][w]
  message_schedule M_t = W
    where
      W = (groupBy `{w} M_t) # [
          ROTL `{1} (W@(t-3) ^ W@(t-8) ^ W@(t-14) ^ W@(t-16))
          | t <- [16..79]
          ]

  /**
   * The SHA1 hash state is iteratively mixed
   * according to the following formula.
   *
   * References:
   * [FIPS-180-4] Section 6.1.2 Part 3
   */
  mix_one: {t} (t <= 79) => [w] -> LetterVars -> LetterVars
  mix_one W_t (a, b, c, d, e) = (a', b', c', d', e')
    where
      T = ROTL `{5} a + f `{t} b c d + e + K `{t} + W_t
      e' = d
      d' = c
      c' = ROTL `{30} b
      b' = a
      a' = T

  /**
   * The SHA1 hash state is mixed over `t` ranging
   * from `0` to `79` inclusive.
   *
   * References:
   * [FIPS-180-4] Section 6.1.2 Part 3
   */
  mix: {t} (t <= 79) => [80][w] -> LetterVars -> LetterVars
  mix W h | t < 79 => mix `{t + 1} W (mix_one `{t} (W@`t) h)
          | t == 79 => mix_one `{t} (W@`t) h

  /**
   * SHA1 hashes computed over a state of `5` `32` bit words.
   * Each `m` bit block is processed in-order.
   * This function computes SHA1 on one block.
   *
   * References:
   * [FIPS-180-4] Section 6.1.2
   */
  sha1_block: LetterVars -> [BlockSize] -> LetterVars
  sha1_block (h0, h1, h2, h3, h4) M_t = (a + h0, b + h1, c + h2, d + h3, e + h4)
    where
      W = message_schedule M_t
      (a, b, c, d, e) = mix `{0} W (h0, h1, h2, h3, h4)
