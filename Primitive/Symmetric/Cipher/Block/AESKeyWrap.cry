// Cryptol AES Key Wrap Implementation
// Copyright (c) 2020, Galois Inc.
// www.cryptol.net
// You can freely use this source code for educational purposes.

// This is a close implementation of RFC 3394:
// https://tools.ietf.org/html/rfc3394
// RFC 3394 provides two equivalent descriptions of AES Key Wrap, one using
// shifting and the other using indexing.  This specification closely matches
// the index-based algorithm description as that description is more similar
// to the BoringSSL AES Key Wrap implementation.

module Primitive::Symmetric::Cipher::Block::AESKeyWrap where
import Primitive::Symmetric::Cipher::Block::AES

// Default intial value (Section 2.2.3)
DefaultIV : [8][8]
DefaultIV = [0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6]

// Wrap `plaintext` using `key` as the key encryption key.  `iv` is the initial
// value to use.  This function implements the algorithm from Section 2.2.1
// using the index-based definition.
aesWrapKey : {n} (fin n, n >= 16, n % 8 == 0, width (n / 8) <= 64) =>
             [AESKeySize] -> [8][8] -> [n][8] -> [n+8][8]
aesWrapKey key iv plaintext = split (join C)
  where
    // Step 1: Initialize variables
    A = join iv
    R = split`{parts=n/8, each=64} (join plaintext)
    // Step 2: calculate intermediate values
    intermediates = [(A, R)] # [wrapRound key s j | s <- intermediates
                                                  | j <- [0..5]]
    // Step 3: Prepare outputs
    (A', R') = intermediates ! 0
    C = [A'] # R'

// Unwrap `ciphertext` using `key` as the key encryption key.  `iv` is the
// expected initial value.  This function implements the algorithm from Section
// 2.2.2 using the index-based definition.  It also checks the key data
// integrity using `iv` (Section 2.2.3) and raises an error if the integrity
// check fails.
aesUnwrapKey : {n} (fin n, n >= 24, n % 8 == 0, width (n / 8) <= 64) =>
               [AESKeySize] -> [8][8] -> [n][8] -> [n-8][8]
aesUnwrapKey key iv ciphertext = if ((join iv) == A')
                                 then split (join R')
                                 else error "IV mismatch in decrypted ciphertext"
  where
    // Step 1: Initialize variables
    A = join (take`{8} ciphertext)
    R = split`{parts=(n-8)/8, each=64} (join (drop`{8} ciphertext))
    // Step 2: Compute intermediate values
    intermediates = [(A, R)] # [unwrapRound key s j | s <- intermediates
                                                    | j <- [5, 4 .. 0]]
    // Step 3: Prepare outputs
    (A', R') = intermediates ! 0

private
  /////////////////////////////////////////////////////////////////////////////
  //// Helper functions
  /////////////////////////////////////////////////////////////////////////////

  /*
   * This section contains helper functions for wrapping and unwrapping keys.
   * These functions make use of the notation defined in Section 2.1 of
   * RFC 3394.
   */

  // Body of inner loop of step 2 of key wrap algorithm (Section 2.2.1)
  wrapBlock : {n} (fin n, width n <= 64) =>
              [AESKeySize] -> ([64], [n][64]) -> [64] -> [64] -> ([64], [n][64])
  wrapBlock key (A, R) j i = (A', R')
    where B  = aesEncrypt (A # (R @ (i-1)), key)
          A' = (take`{64} B) ^ (((`n : [64]) * j) + i)
          R' = update R (i-1) (drop`{64} B)

  // Body of inner loop of step 2 of key unwrap algorithm (Section 2.2.2)
  unwrapBlock : {n} (fin n, width n <= 64) =>
                [AESKeySize] -> ([64], [n][64]) -> [64] -> [64] -> ([64], [n][64])
  unwrapBlock key (A, R) j i = (A', R')
    where B  = aesDecrypt ((A ^ (((`n : [64]) * j) + i)) # (R @ (i-1)), key)
          A' = take`{64} B
          R' = update R (i-1) (drop`{64} B)

  // A single round of the key wrap algorithm (Section 2.2.1, step 2)
  wrapRound : {n} (fin n, n >= 1, width n <= 64) =>
              [AESKeySize] -> ([64], [n][64]) -> [64] -> ([64], [n][64])
  wrapRound key (A, R) j = wrappedBlocks ! 0
    where wrappedBlocks = [(A, R)] # [wrapBlock key s j i | s <- wrappedBlocks
                                                          | i <- [1..n]]

  // A single round of the key unwrap algorithm (Section 2.2.2, step 2)
  unwrapRound : {n} (fin n, n >= 1, width n <= 64) =>
                [AESKeySize] -> ([64], [n][64]) -> [64] -> ([64], [n][64])
  unwrapRound key (A, R) j = unwrappedBlocks ! 0
    where unwrappedBlocks = [(A, R)] # [unwrapBlock key s j i | s <- unwrappedBlocks
                                                              | i <- [n, n-1 .. 1]]

  /////////////////////////////////////////////////////////////////////////////
  //// Tests
  /////////////////////////////////////////////////////////////////////////////

  // This section contains tests of the Key Wrap specifications using test
  // vectors from Section 4 of RFC 3394.

  // 256-bit key encryption key (KEK) used to encrypt the key data
  KEK256 : [AESKeySize]
  KEK256 = 0x000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F

  // 128-bit key data to encrypt
  KeyData128 : [16][8]
  KeyData128 = split 0x00112233445566778899AABBCCDDEEFF

  // Expected ciphertext from encrypting KeyData128 with KEK256
  Ciphertext128_256 : [24][8]
  Ciphertext128_256 = split 0x64E8C3F9CE0F5BA263E9777905818A2A93C8191E7D6E8AE7

  // Test wrapping and unwrapping of KeyData128 with KEK256 (Section 4.3)
  property testWrap128_256 = (aesWrapKey KEK256 DefaultIV KeyData128) == Ciphertext128_256
  property testUnwrap128_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext128_256) == KeyData128

  // 192-bit key data to encrypt
  KeyData192 : [24][8]
  KeyData192 = split 0x00112233445566778899AABBCCDDEEFF0001020304050607

  // Expected ciphertext from encrypting KeyData192 with KEK256
  Ciphertext192_256 : [32][8]
  Ciphertext192_256 = split 0xA8F9BC1612C68B3FF6E6F4FBE30E71E4769C8B80A32CB8958CD5D17D6B254DA1

  // Test wrapping and unwrapping of KeyData192 with KEK256 (Section 4.5)
  property testWrap192_256 = (aesWrapKey KEK256 DefaultIV KeyData192) == Ciphertext192_256
  property testUnwrap192_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext192_256) == KeyData192

  // 256-bit key data to encrypt
  KeyData256 : [32][8]
  KeyData256 = split 0x00112233445566778899AABBCCDDEEFF000102030405060708090A0B0C0D0E0F

  // Expected ciphertext from encrypting KeyData256 with KEK256
  Ciphertext256_256 : [40][8]
  Ciphertext256_256 = split 0x28C9F404C4B810F4CBCCB35CFB87F8263F5786E2D80ED326CBC7F0E71A99F43BFB988B9B7A02DD21

  // Test wrapping and unwrapping of KeyData256 with KEK256 (Section 4.6)
  property testWrap256_256 = (aesWrapKey KEK256 DefaultIV KeyData256) == Ciphertext256_256
  property testUnwrap256_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext256_256) == KeyData256
