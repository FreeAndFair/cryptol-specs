// Cryptol AES Implementation
//
// @copyright Galois Inc.
// @author Nichole Shimanski <nls@galois.com>
// @author Marcella Hastings <marcella@galois.com>
// www.cryptol.net
//
//
// References
// [FIPS-197u1]: Morris J. Dworkin, Elaine B. Barker, James R. Nechvatal,
// James Foti, Lawrence E. Bassham, E. Roback, and James F. Dray Jr.
// Advanced Encryption Standard (AES). Federal Inf. Process. Stds. (NIST FIPS)
// 197, update 1. May 2023.
//

module Primitive::Symmetric::Cipher::Block::AES::Algorithm where

import Primitive::Symmetric::Cipher::Block::AES::State (State, RoundKey, msgToState, stateToMsg)
import Primitive::Symmetric::Cipher::Block::AES::Round as Round

parameter
  /** 0: AES128, 1: AES192, 2: AES256 */
  type Mode : #
  type constraint (2 >= Mode)

/* The following section encodes [FIPS-197u1] Section 5, Table 3
 * The table is described in terms of the `Mode`.
 */

/** Key length: number of 32 bit words in the key */
type Nk = 4 + 2 * Mode

/** Number of rounds */
type Nr = 6 + Nk

/** The keys for all the rounds */
type KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)

/**
 * The general function for executing AES with 128-, 192-, or 256-bit keys.
 *
 * Corresponds to [FIPS-197u1] Section 5.1, Algorithm 1.
 *
 * In the spec, the three inputs to `Cipher` are the input data, the number of
 * rounds `Nr`, and the round keys. In this implementation, we don't explicitly
 * pass `Nr` as a parameter; instead it's defined as a type above. We also
 * switch the order of the input and keys.
 */
cipher: KeySchedule -> [128] -> [128]
cipher (kInit,ks,kFinal) pt =
    // Lines 10-13
    stateToMsg (Round::AESFinalRound kFinal (rounds ! 0))
  where
    // Lines 2-3
    state0 = kInit ^ msgToState pt
    // Lines 4-9
    rounds = [state0] # [ Round::AESRound rk s | rk <- ks | s <- rounds ]

/**
 * The general function for inverting AES with 128-, 192-, or 256-bit keys.
 *
 * This inverts and reverses the order of the transformations in `cipher`.
 * Corresponds to [FIPS-197u1] Section 5.3, Algorithm 3.
 *
 * In the spec, the three inputs to `InvCipher` are the input data, the number of
 * rounds `Nr`, and the round keys. In this implementation, we don't explicitly
 * pass `Nr` as a parameter; instead it's defined as a type above. We also
 * switch the order of the input and keys.
 */
invCipher: KeySchedule -> [128] -> [128]
invCipher (kInit, ks, kFinal) ct =
    // Lines 10-13
    stateToMsg (Round::AESFinalInvRound kInit (rounds ! 0))
  where
    // Lines 2-3
    state0 = kFinal ^ msgToState ct
    // Lines 4-9
    rounds = [state0] # [ Round::AESInvRound rk s | rk <- (reverse ks) | s <- rounds ]
