/**
 * Implementation of the XTS Tweakable Block Cipher mode.
 *
 * @copyright Galois, Inc
 * @author Eric Mertens <emertens@galois.com>
 *
 * References:
 * - NIST SP 800-38E: Recommendation for Block Cipher Modes of Operation:
 *   The XTS-AES Mode for Confidentiality on Storage Devices [NIST]
 * - IEEE Std 1619-2007, The XTS-AES Tweakable Block Cipher, Institute of
 *   Electrical and Electronics Engineers, Inc., Apr. 18, 2008. [IEEE2007]
 * - IEEE Std 1619-2018, The XTS-AES Tweakable Block Cipher, Institute of
 *   Electrical and Electronics Engineers, Inc., Oct. 23 2018 [IEEE2018]
 */
module Primitive::Symmetric::Cipher::Block::Modes::XTS where

import interface Primitive::Symmetric::Cipher::Block::CipherInterface as C

/*
 * XTS encrypts a `data stream` that is divided into consecutive equal size
 * `data units`.
 *
 * References:
 *   [IEEE2007] Section 5.1
 *   [IEEE2018] Section 5.1
 */

/**
 * In particular, the result of AES encryption and decryption (a 16-byte value) is
 * multiplied by a primitive element of GF(2^128) during the encryption and decryption
 * procedures.
 *
 * References:
 *   [IEEE2007] Section 5.2
 *   [IEEE2018] Section 5.2
 */
interface constraint (C::BlockSize == 128)

/**
 * Cryptol treats all bitvectors in big-endian numbers.
 * The specification treats byte arrays as little-endian numbers
 * for the purposes of encrypting the tweak.
 *
 * References:
 *   [IEEE2007] Section 5.2
 *   [IEEE2018] Section 5.2
 */
flipEndian : [128] -> [128]
flipEndian x = join (reverse (groupBy`{8} x))

/**
 * The `flipEndian` procedure is its own inverse.
 *
 * ```repl
 * :prove flipEndianInvolutive
 * ```
 */
property flipEndianInvolutive x = flipEndian (flipEndian x) == x

/**
 * NIST SP 800-38E states: The length of the data unit for any instance of
 * an implementation of XTS-AES shall not exceed 2^20 AES blocks.
 *
 * This restriction of _within a data unit_ is consistent with both
 * [IEEE2007] and [IEEE2018].
 *
 * [IEEE2007] and [IEEE2018] Section 5.3.2 imply the data unit must be
 * at least the length of the block size. The final block, presuming there
 * is at least one full block, can be extended with ciphertext stealing,
 * but there is no such scheme if the plaintext length is too short.
 */
type constraint ValidLength n = (n /^ C::BlockSize <= 2^^20, n >= C::BlockSize, fin n)

/**
 * 5.1 Computing initial tweak from a data unit number.
 *
 * The initialization vector is defined to be a little-endian, zero-padded
 * representation of the data unit sequence number.
 *
 * Technically, per 5.1 the tweak is a non-negative integer.
 * When it is encrypted, it is converted to a little-endian byte array.
 * It must be the correct block size for AES encryption/decryption, hence,
 * the padding.
 *
 * Per section 5.3.1, the tweak is a 128 bit value.
 *
 * References:
 *   [IEEE2007] Section 5.1, 5.3.1
 *   [IEEE2018] Section 5.1, 5.3.1
 */
dataUnitSeqNoToIV : {n} (n <= 128) => [n] -> [128]
dataUnitSeqNoToIV S = flipEndian (zext S)

/**
 * Example found in 5.1
 *
 * ```repl
 * :prove dataUnitSeqNoExample
 * ```
 */
property dataUnitSeqNoExample = dataUnitSeqNoToIV 0x123456789a == 0x9a785634120000000000000000000000

/**
 * 5.2 Multiplication by a primitive element ɑ
 *
 *  The next tweak value is computed by performing a GF128 multiplication of
 *  α modulo an irreducible polynomial.
 */
stepTweak : [128] -> [128]
stepTweak x = flipEndian (f (flipEndian x))
  where
    f p = pmod (pmult p α) irreducible

/**
 * The IEEE standard `α` to be the polynomial `x` in GF(2^128).
 * This is a primitive polynomial in this field, which means taking
 * powers of `α` generate all non-zero elements of the field.
 *
 * References:
 *  [IEEE2007] Section 4.2
 *  [IEEE2018] Section 4.2
 */
α : [2]
α = <| x |>

/**
 * Irreducible polynomial defining GF(2^128).
 *
 * References:
 *  [IEEE2007] Section 4.2
 *  [IEEE2018] Section 4.2
 */
irreducible : [129]
irreducible = <| x^^128 + x^^7 + x^^2 + x + 1 |>

/**
 * Generates an infinite stream of tweak blocks to be used in encryption and
 * decryption given an initialization vector. This can be thought of as
 * multiplication by successive powers of α, starting with the zeroth power,
 * with an initial value of the encryption of the first tweak.
 *
 * Here, the tweak has already been converted to a 128 bit value,
 * per Section 5.3.1 of the IEEE standards.
 */
generateTweaks : [C::KeySize] -> [128] -> [inf][128]
generateTweaks K2 i = iterate stepTweak (C::encrypt K2 i)

/**
 * 5.3.1 encryption of a single 128-bit block
 */
encryptBlock : [C::KeySize] -> [128] -> [128] -> [128]
encryptBlock K T P = C
  where
    // `T` is computed externally using the
    // `generateTweaks` function in this implementation.
    PP = T ^ P // line (2), 5.3.1
    CC = C::encrypt K PP // line (3), 5.3.1
    C  = CC ^ T // line (4), 5.3.1

/**
 *  5.3.2 encryption of a data unit.
 *
 * Here, the sequence number `j` is implicit, and
 * is handled by `generateTweaks`.
 */
encrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]
encrypt (K1 # K2) i P
  | 0 == n % 128 => join [ encryptBlock K1 T blk
                         | T <- generateTweaks K2 i // line (1), 5.3.1
                         | blk <- split`{n / 128} P ]
  | otherwise => C
    where
      // Number of full blocks of plaintext
      // Section 5.3.2 calls `M` `m`.
      type M = n / 128

      // Generate `M + 1` tweaks.
      // If `Pm`, the final block, is empty,
      // we will not need this tweak.
      T_0_m1 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)

      // Partition `P` into `M + 1` blocks.
      // The first `m` blocks are all 128 bits long.
      // The final block, `Pm`, is between `0` and `127` bits long.
      P_0_m2 # Pm1 # Pm = P

      // Encrypt all but the final two blocks.
      C_0_m2 = join [encryptBlock K1 T blk | T <- T_0_m1 | blk <- split`{M - 1} P_0_m2]

      // Encrypt `P m - 1`, the final full block.
      // Let `b` be the length of `Pm`.
      // Steal the last `b` bits of the encryption
      // to "pad" the length of `Pm`.
      Cm # CP = encryptBlock K1 Tm1 Pm1
      Cm1 = encryptBlock K1 Tm (Pm # CP)
      C = C_0_m2 # Cm1 # Cm

/**
 * Convenience type-constraint that is always satisified.
 * The name is inspired by the Haskell `otherwise` guard.
 */
type constraint otherwise = ()

/**
 * 5.4.1 decryption of a single 128-bit block
 */
decryptBlock : [C::KeySize] -> [128] -> [128] -> [128]
decryptBlock K T C = P
  where
    // Like `encryptBlock`, `T` is computed externally to
    // this procedure in this implementation.
    CC = C ^ T
    PP = C::decrypt K CC
    P = PP ^ T

/**
 * 5.4.2 decryption of a data unit
 */
decrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]
decrypt (K1 # K2) i C
  | 0 == n % 128 => join [ decryptBlock K1 T blk
                         | T <- generateTweaks K2 i
                         | blk <- split`{n / 128} C]
  | otherwise => P
    where
      // Number of full blocks of ciphertext
      type M = n / 128

      // Generate tweaks.
      T_0_m2 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)

      // Assemble the plaintext.
      P = P_0_m2 # Pm1 # Pm

      // Decrypt the second to last block by replacing the stolen ciphertext.
      Pm1 = decryptBlock K1 Tm1 (Cm # CP)
      // Decrypt the full blocks.
      P_0_m2 = join [decryptBlock K1 T blk | T <- T_0_m2 | blk <- split`{M - 1} C_0_m2]
      // Retrieve the stolen ciphertext from the decryption of the final block.
      Pm # CP = decryptBlock K1 Tm Cm1
      // Partiiton the ciphertext into `M` full blocks and a possibly
      // empty final block.
      C_0_m2 # Cm1 # Cm = C

/**
 * Decryption inverts encryption.
 * This is a fundamental correctness property.
 *
 * ```repl
 * :check decryptInvertsEncrypt `{192}
 * ```
 */
decryptInvertsEncrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> Bool
property decryptInvertsEncrypt K i P = decrypt K i (encrypt K i P) == P
