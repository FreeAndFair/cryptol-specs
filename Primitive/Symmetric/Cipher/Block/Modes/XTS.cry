/**
 * Implementation of the XTS Tweakable Block Cipher mode.
 *
 * @copyright Galois, Inc
 * @author Eric Mertens <emertens@galois.com>
 *
 * References:
 * - NIST SP 800-38E: Recommendation for Block Cipher Modes of Operation:
 *   The XTS-AES Mode for Confidentiality on Storage Devices [NIST]
 * - IEEE Std 1619-2007, The XTS-AES Tweakable Block Cipher, Institute of
 *   Electrical and Electronics Engineers, Inc., Apr. 18, 2008. [IEEE2007]
 * - IEEE Std 1619-2018, The XTS-AES Tweakable Block Cipher, Institute of
 *   Electrical and Electronics Engineers, Inc., Oct. 23 2018 [IEEE2018]
 */
module Primitive::Symmetric::Cipher::Block::Modes::XTS where

import interface Primitive::Symmetric::Cipher::Block::CipherInterface as C

/*
 * XTS encrypts a `data stream` that is divided into consecutive equal size
 * `data units`.
 *
 * References:
 *   [IEEE2007] Section 5.1
 *   [IEEE2018] Section 5.1
 */

/**
 * In particular, the result of AES encryption and decryption (a 16-byte value) is
 * multiplied by a primitive element of GF(2^128) during the encryption and decryption
 * procedures.
 *
 * References:
 *   [IEEE2007] Section 5.2
 *   [IEEE2018] Section 5.2
 */
interface constraint (C::BlockSize == 128)

/**
 * Cryptol treats all bitvectors in big-endian numbers.
 * The specification treats byte arrays as little-endian numbers
 * for the purposes of encrypting the tweak.
 *
 * References:
 *   [IEEE2007] Section 5.2
 *   [IEEE2018] Section 5.2
 */
flipEndian : [128] -> [128]
flipEndian x = join (reverse (groupBy`{8} x))

/**
 * The `flipEndian` procedure is its own inverse.
 *
 * ```repl
 * :prove flipEndianInvolutive
 * ```
 */
property flipEndianInvolutive x = flipEndian (flipEndian x) == x

/**
 * NIST SP 800-38E states: The length of the data unit for any instance of
 * an implementation of XTS-AES shall not exceed 2^20 AES blocks.
 *
 * This restriction of _within a data unit_ is consistent with both
 * [IEEE2007] and [IEEE2018].
 */
type constraint ValidLength n = (n /^ C::BlockSize <= 2^^20, n >= C::BlockSize, fin n)

/**
 * 5.1 Computing initial tweak from a data unit number.
 *
 * The initialization vector is defined to be a little-endian, zero-padded
 * representation of the data unit sequence number.
 */
dataUnitSeqNoToIV : {n} (n <= 128) => [n] -> [128]
dataUnitSeqNoToIV S = flipEndian (zext S)

/**
 * Example found in 5.1
 *
 * ```repl
 * :prove dataUnitSeqNoExample
 * ```
 */
property dataUnitSeqNoExample = dataUnitSeqNoToIV 0x123456789a == 0x9a785634120000000000000000000000

/**
 * 5.2 Multiplication by a primitive element ɑ
 *
 *  The next tweak value is computed by performing a GF128 multiplication of
 *  α modulo an irreducible polynomial.
 */
stepTweak : [128] -> [128]
stepTweak x = flipEndian (f (flipEndian x))
  where
    f p = pmod (pmult p α) irreducible

/**
 * The IEEE standard `α` to be the polynomial `x` in GF(2^128).
 * This is a primitive polynomial in this field, which means taking
 * powers of `α` generate all non-zero elements of the field.
 *
 * References:
 *  [IEEE2007] Section 4.2
 *  [IEEE2018] Section 4.2
 */
α : [2]
α = <| x |>

/**
 * Irreducible polynomial defining GF(2^128).
 *
 * References:
 *  [IEEE2007] Section 4.2
 *  [IEEE2018] Section 4.2
 */
irreducible : [129]
irreducible = <| x^^128 + x^^7 + x^^2 + x + 1 |>

/**
 * Generates an infinite stream of tweak blocks to be used in encryption and
 * decryption given an initialization vector.
 */
generateTweaks : [C::KeySize] -> [128] -> [inf][128]
generateTweaks K2 i = iterate stepTweak (C::encrypt K2 i)

/**
 * 5.3.1 encryption of a single 128-bit block
 */
encryptBlock : [C::KeySize] -> [128] -> [128] -> [128]
encryptBlock K T P = T ^ C::encrypt K (T ^ P)

/**
 *  5.3.2 encryption of a data unit.
 */
encrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]
encrypt (K1 # K2) i P
  | 0 == n % 128 => join [ encryptBlock K1 T blk
                         | T <- generateTweaks K2 i
                         | blk <- split`{n / 128} P ]
  | otherwise => C
    where
      // Number of full blocks of plaintext
      type M = n / 128

      T_0_m1 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)

      P_0_m2 # Pm1 # Pm = P
      C_0_m2 = join [encryptBlock K1 T blk | T <- T_0_m1 | blk <- split`{M - 1} P_0_m2]
      Cm # CP = encryptBlock K1 Tm1 Pm1
      Cm1 = encryptBlock K1 Tm (Pm # CP)
      C = C_0_m2 # Cm1 # Cm

/**
 * Convenience type-constraint that is always satisified.
 * The name is inspired by the Haskell `otherwise` guard.
 */
type constraint otherwise = ()

/**
 * 5.4.1 decryption of a single 128-bit block
 */
decryptBlock : [C::KeySize] -> [128] -> [128] -> [128]
decryptBlock K T C = T ^ C::decrypt K (T ^ C)

/**
 * 5.4.2 decryption of a data unit
 */
decrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]
decrypt (K1 # K2) i C
  | 0 == n % 128 => join [ decryptBlock K1 T blk
                         | T <- generateTweaks K2 i
                         | blk <- split`{n / 128} C]
  | otherwise => P
    where
      // Number of full blocks of ciphertext
      type M = n / 128

      T_0_m2 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)

      P = P_0_m2 # Pm1 # Pm
      Pm1 = decryptBlock K1 Tm1 (Cm # CP)
      P_0_m2 = join [decryptBlock K1 T blk | T <- T_0_m2 | blk <- split`{M - 1} C_0_m2]
      Pm # CP = decryptBlock K1 Tm Cm1
      C_0_m2 # Cm1 # Cm = C

/**
 * Decryption inverts encryption.
 * This is a fundamental correctness property.
 */
decryptInvertsEncrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> Bool
property decryptInvertsEncrypt K i P = decrypt K i (encrypt K i P) == P
