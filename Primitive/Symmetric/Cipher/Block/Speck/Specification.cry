/**
 * @copyright Galois, Inc.
 *
 * This module provides a Cryptol specification of the Speck block cipher.
 * Speck is abstracted over the key size, the block size, the number of
 * rounds, and two rotation constants.
 *
 * @author John Christensen <jchristensen@galois.com>
 * @author David Lazar
 *
 * References
 * [SPECK]: Beaulieu, Shors, Smith, Treatman-Clark, Weeks, Wingers
 *          The Simon and Speck Families of Lightweight Block Ciphers
 *          19 June 2013
 */

module Primitive::Symmetric::Cipher::Block::Speck::Specification where

parameter

    /**
     * `n` is the Speck word size in bits.
     * `2 * n` is the Speck block size.
     */
    type n : #

    /**
     * `m` is the number of words in the Speck key.
     * Thus, the length of the Speck key is `n * m` bits.
     */
    type m : #

    /**
     * `alpha` is a rotation constant.
     */
    type alpha : #

    /**
     * `beta` is a rotation constant.
     */
    type beta : #

    /**
     * `T` is the number of rounds.
     */
    type T : #

    /**
     * The following type constraints satisfy Cryptol's type checker.
     * They admit all valid Speck instantiations.
     * They do not exclude all invalid instantiations.
     */
    type constraint (fin n, fin T, fin m, n >= width alpha, n >= width beta)
    type constraint (m >= 2, m <= 4, T >= 2, n >= width T)

/**
 * The Speck encryption function is the composition of `T` round functions.
 * Each of the `T` round function is derived from the key by the key schedule.
 *
 * Reference: [SPECK], Section 4.1
 */
encrypt : [m * n] -> [2 * n] -> [2 * n]
encrypt key plaintext = join (Speck_k (split plaintext))
    where
        // The Speck specification document parses the key LSB first.
        // Cryptol parses all bitvectors MSB first.
        // Thus, we reverse the key to match the
        // convention of the specification.
        Rks = map (\k -> R k) (keySchedule (reverse (split key)))
        Speck_k = composeMany Rks

/**
 * The Speck decryption function is the inverse of the encryption function.
 * To derive the inverse, the round functions are composed in reverse order.
 *
 * Reference: [SPECK], Section 4.1.
 */
decrypt : [m * n] -> [2 * n] -> [2 * n]
decrypt key ciphertext = join (Speck_k (split ciphertext))
    where
        // As in `encrypt`, we reverse the key.
        Rks = map (\k -> R_Inv k) (keySchedule (reverse (split key)))
        Speck_k = composeMany (reverse Rks)

private

    /**
     * The encryption and decryption functions are inverses of each other.
     *
     * ```repl
     * :check decryptInvertsEncrypt
     * ```
     */
    property decryptInvertsEncrypt k x = decrypt k (encrypt k x) == x

    /**
     * The Speck key schedule.
     * This procedure generates the round keys from which
     * each round function is derived. This procedure relies
     * on the constituent functions that make up the round
     * function.
     *
     * Reference: [Speck], Section 4.2.
     */
    keySchedule : [m][n] -> [T][n]
    keySchedule K = ks
        where
            // write key K as (k0, l0, ... l_m-2)
            [k0] # li = K
            // define mutual recursion of sequences ki and li
            ks = [k0] # [Sb (ks @ i) ^ (ls @ (i + `m - 1)) | i <- [0..T - 2]]
            ls = li # [(k + Sa_Inv (ls @ i)) ^ i | k <- ks | i <- [0..T - 2] ]

    /**
     * The Speck key schedule, formulated in terms of the Speck round function.
     * The formula in the specification explicitly unfolds these definitions;
     * this formula leaves the definitions folded to illuminate the usage of
     * the constituent functions.
     *
     * Reference: [SPECK], Section 4.2.
     */
    keySchedule' : [m][n] -> [T][n]
    keySchedule' K = ks
        where
            // write key K as (k0, l0, ... l_m-2)
            [k0] # li = K
            // define mutual recursion of sequences ki and li
            ks = [k0] # [f2 [(ks @ i), (ls @ (i + `m - 1))] | i <- [0..T - 2]]
            ls = li # [f1 i [ls @ i, k] | k <- ks | i <- [0..T - 2] ]
            // the key schedule uses the half of the output of the Speck round
            // functions, discarding the half that isn't transformed by the
            // Feistel-like map. The "key" for f1, in this case, is a counter.
            f1 k s = (Rf1 k s) @ 1
            f2 s = (Rf2 s) @ 1

    /**
     * The key schedule is injective.
     *
     * ```repl
     * :prove keyScheduleInjective
     * ```
     */
    property keyScheduleInjective k v = k != v ==> result
        where
            result = keySchedule k != keySchedule v

    /**
     * The key schedule formulations are equiavalent.
     *
     * ```repl
     * :prove keySchedulesEquivalent
     * ```
     */
    property keySchedulesEquivalent K = keySchedule K == keySchedule' K

    /**
     * The Speck round function. This function is parameterized by a key.
     * This function is a composition of shifts and modular additions.
     *
     * Reference: [SPECK], Section 4.1.
     */
    R : [n] -> [2][n] -> [2][n]
    R k [x, y] = [(Sa_Inv x + y) ^ k, Sb y ^ (Sa_Inv x + y) ^ k]

    /**
     * The inverse Speck round function.
     *
     * Reference: [SPECK], Section 4.1.
     */
    R_Inv : [n] -> [2][n] -> [2][n]
    R_Inv k [x, y] = [Sa ((x ^ k) - Sb_Inv (x ^ y)), Sb_Inv (x ^ y)]

    /**
     * `R_Inv` is the inverse of `R`.
     *
     * ```repl
     * :prove RInvertible
     * ```
     */
    property RInvertible k x = R_Inv k (R k x) == x

    /**
     * `R` can be decomposed as two Feistel-like maps
     * with respect to modular addition. This is the
     * map with addition modulo `2^n`. Part of this function's
     * output is used in the key schedule.
     *
     * Reference: [SPECK], Section 4.1, 4.2.
     */
    Rf1 : [n] -> [2][n] -> [2][n]
    Rf1 k [x, y] = [y, (Sa_Inv x + y) ^ k]

    /**
     * `R` can be decomposed as two Feistel-like maps
     * with respect to modular addition. This is the
     * map with addition modulo `2` (i.e., XOR). Part of
     * this function's output is used in the key schedule.
     *
     * Note that this function has no key dependence.
     *
     * Reference: [SPECK], Section 4.1, 4.2.
     */
    Rf2 : [2][n] -> [2][n]
    Rf2 [x, y] = [y, Sb x ^ y]

    /**
     * Composition of the Feistel-like maps.
     * An alternative formulation of `R`.
     */
    Rf : [n] -> [2][n] -> [2][n]
    Rf k s = f s
        where
            f = compose (Rf1 k) Rf2

    /**
     * `Rf` is functionally equiavalent to `R`.
     *
     * ```repl
     * :prove REquivalent
     * ```
     */
    property REquivalent k s = Rf k s == R k s

    /**
     * Left circular shift.
     * The notation `S` is used because it appears in the specification.
     *
     * Reference: [SPECK], Section 4.1.
     */
    S : {j} (fin j) => [n] -> [n]
    S x = x <<< `j

    /**
     * Right circular shift.
     * The notation `S_Inv` is used rather than using 'negative exponents'
     * to avoid arithmetic strangeness with negative bitvectors.
     *
     * Reference: [SPECK], Section 4.1.
     */
    S_Inv : {j} (fin j) => [n] -> [n]
    S_Inv x = x >>> `j

    /**
     * Left ciruclar shift by the rotation constant alpha.
     *
     * Reference: [SPECK], Section 4.1.
     */
    Sa x = S `{alpha} x

    /**
     * Left ciruclar shift by the rotation constant beta.
     *
     * Reference: [SPECK], Section 4.1.
     */
    Sb x = S `{beta} x

    /**
     * Right ciruclar shift by the rotation constant alpha.
     *
     * Reference: [SPECK], Section 4.1.
     */
    Sa_Inv x = S_Inv `{alpha} x

    /**
     * Right ciruclar shift by the rotation constant beta.
     *
     * Reference: [SPECK], Section 4.1.
     */
    Sb_Inv x = S_Inv `{beta} x

    /**
     * Function composition, specialized to functions from `(a -> a)`.
     */
    compose : {a} () => (a -> a) -> (a -> a) -> a -> a
    compose f g = \x -> g (f x)

    /**
     * Composition of many functions from `(a -> a)`.
     */
    composeMany : {nf, a} (fin n) => [nf](a -> a) -> a -> a
    composeMany fcns
        | nf == 0 => \x -> x
        | nf == 1 => fcns@0
        | nf == 2 => compose (fcns@0) (fcns@1)
        | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))
