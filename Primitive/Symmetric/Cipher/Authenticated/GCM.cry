/*
Galois Counter Mode in Cryptol
Copyright (c) 2017-2018, Galois, Inc.
Author: Sean Weaver, Marcella Hastings

This implementation follows NIST special publication 800-38D:
[NIST-SP-800-38D] Morris Dworkin. Recommendation for Block Cipher Modes
of Operation: Galois/Counter Mode (GCM) and GMAC. NIST Special
Publication 800-38D. November 2007.
*/

module Primitive::Symmetric::Cipher::Authenticated::GCM where
import interface Primitive::Symmetric::Cipher::Block::CipherInterface as C

// GCM mode is only defined for ciphers that operate over 128-bit blocks.
interface constraint (C::BlockSize == 128)

type constraint ValidIV IV = (64 >= width IV, IV >= 1)
type constraint ValidAAD AAD = (64 >= width AAD)
type constraint ValidTag T = (128 >= T, T >= 64)
/**
 * The plaintext (for encryption) and ciphertext (for decryption) must not
 * be too large.
 * This constraint comes from [NIST-SP-800-38D].
 */
type constraint ValidText P = (fin P, P <= 2^^39 - 256 )

/**
 * GCM-AE Function, [NIST-SP-800-38D] Section 7.1, Algorithm 4. This provides
 * authenticated encryption.
 */

GCM_AE : { P, IV, AAD, T } (ValidText P, ValidIV IV, ValidAAD AAD, ValidTag T)
 => [C::KeySize] -> [IV] -> [P] -> [AAD] -> ([P], [T])
GCM_AE k iv p a = (C, T)
  where
    // Set names to match the spec
    CIPHk = C::encrypt k
    type len_A = AAD
    // Ciphertext length is the same as the input plaintext length
    type len_C = P

    H = CIPHk 0
    J0 = define_J0 k iv H
    C = GCTR CIPHk (inc`{32} J0) p
    type u = len_C %^ 128 // Equivalently: 128 * len_C /^ 128 - len_C
    type v = len_A %^ 128 // Equivalently: 128 * len_A /^ 128 - len_A
    S = GHASH`{len_A/^ 128 + P /^ 128 + 1}
            H (a # (0 : [v]) # C # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))
    T = MSB`{T} (GCTR CIPHk J0 S)

/**
 * GCM-AD Function, [NIST-SP-800-38D] Section 7.2, Algorithm 5. This provides
 * authenticated decryption.
 */

GCM_AD : { C, IV, AAD, T } (ValidText C, ValidIV IV, ValidAAD AAD, ValidTag T)
 => [C::KeySize] -> [IV] -> [C] -> [AAD] -> [T] -> { valid : Bool, pt : [C] }
GCM_AD key iv ct aad tag =
  if tag == T'
  then { valid = True, pt = P }
  else { valid = False, pt = 0 }
  where
    CIPHk = C::encrypt key
    len_IV = `IV
    type len_A = AAD
    type len_C = C

    H = CIPHk 0
    J0 = define_J0 key iv H
    P = GCTR CIPHk (inc`{32} J0) ct
    type u = len_C %^ 128 // Equivalently: 128 * len_C /^ 128 - len_C
    type v = len_A %^ 128 // Equivalently: 128 * len_A /^ 128 - len_A
    S = GHASH`{len_A /^ 128 + len_C /^ 128 + 1}
            H (aad # (0 : [v]) # ct # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))
    T' = MSB`{T} (GCTR CIPHk J0 S)

/**
* Property demonstrating equivalence between `mult` and `•`.
*/
property dotAndMultAreEquivalent X Y = mult X Y == X • Y

/**
 * Property demonstrating that decryption is the inverse of encryption.
 *
 * This should be instantiated for each block cipher `C::encrypt` that uses GCM mode.
 */
gcmIsSymmetric : { P, IV, AAD } ( ValidText P, ValidIV IV, ValidAAD AAD )
  => [C::KeySize] -> [IV] -> [P] -> [AAD] -> Bool
property gcmIsSymmetric key iv pt aad = dec.valid && (dec.pt == pt)
    where
        (ct, tag : [96]) = GCM_AE key iv pt aad
        dec = GCM_AD key iv ct aad tag

private
  /**
  * A helper function used in GCM_AE and GCM_AD. We must define this at the top
  * level due to its use of Cryptol's numeric constraint guards feature, which
  * currently only works in top-level definitions.
  *
  * This renames the IV type to `len_IV` to better match [NIST-SP-800-38D].
  */
  define_J0 : { len_IV } ( ValidIV len_IV ) => [C::KeySize] -> [len_IV] -> [128] -> [128]
  define_J0 k iv H
    | len_IV == 96 => iv # (0 : [31]) # (1 : [1])
    | len_IV != 96 => GHASH`{len_IV /^ 128 + 1} H (iv # (0 : [s + 64]) # (`len_IV: [64]))
    where
      // Set names to match the spec
      type s = len_IV %^ 128  // Equivalently: 128 * len_IV /^ 128 - len_IV

  /**
  * Multiplication Operation on Blocks, [NIST-SP-800-38D] Section
  * 6.3, Algorithm 1. This is optimized to use Cryptol's built-in `pmult` and
  * `pmod` functions. This operation is described using little-endian
  * notation, hence the `reverse`s.
  */

  (•) : [128] -> [128] -> [128]
  (•) X Y = reverse (pmod (pmult (reverse X) (reverse Y))
                          <| 1 + x + x^^2 + x^^7 + x^^128|>)

  /**
  * Multiplication Operation on Blocks, [NIST-SP-800-38D] Section
  * 6.3. This matches the spec very closely.
  */

  mult : [128] -> [128] -> [128]
  mult X Y = last Z
    where
      R = 0b11100001 # (0 : [120])
      Z = [0] # [ if [xi] == 0 then Zi else Zi ^ Vi
                | Zi <- Z
                | xi <- X
                | Vi <- V ]
      V = [Y] # [ if LSB`{1} Vi == 0 then Vi >> 1 else (Vi >> 1) ^ R
                | Vi <- V ]

  /**
  * GHASH Function, [NIST-SP-800-38D] Section 6.4, Algorithm 2.
  */

  GHASH : {m} (fin m) => [128] -> [m * 128] -> [128]
  GHASH H X = last Y
    where Y = [0] # [ (Yi ^ Xi) • H | Yi <- Y | Xi <- groupBy`{128} X ]

  /**
  * The output of incrementing the right-most s bits of the bit
  * string X, regarded as the binary representation of an integer, by
  * 1 modulo 2s, [NIST-SP-800-38D] Sections 4.2.2 and 6.2. Care was
  * taken here to ensure `s` could be zero.
  */

  inc : {s, a} (fin s, fin a, a >= s) => [a] -> [a]
  inc X = MSB`{a-s} X # (LSB`{s} X + take (1 : [max s 1]))


  /**
  * The bit string consisting of the s right-most bits
  * of the bit string X, [NIST-SP-800-38D] Section 4.2.2.
  */

  LSB : {s, a} (fin s, fin a, a >= s) => [a] -> [s]
  LSB X = drop X

  /**
  * The bit string consisting of the s left-most bits of
  * the bit string X, [NIST-SP-800-38D] Section 4.2.2.
  */

  MSB : {s, a} (fin s, a >= s) => [a] -> [s]
  MSB X = take X

  /**
  * GCTR Function, [NIST-SP-800-38D] Section 6.5, Algorithm 3.
  */

  GCTR : {a} (fin a) => ([128] -> [128]) -> [128] -> [a] -> [a]
  GCTR CIPHk ICB X = Y
    where
      Y = X ^ take`{a} (join (map CIPHk CB))
      CB = iterate inc`{32} ICB
