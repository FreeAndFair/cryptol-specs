/*
Galois Counter Mode in Cryptol
Copyright (c) 2017-2018, Galois, Inc.

This implementation follows NIST special publickation 800-38D:
[NISTSP800-38D] Morris Dworkin. Recommendation for Block Cipher Modes
of Operation: Galois/Counter Mode (GCM) and GMAC. NIST Special
Publication 800-38D. November 2007.
*/

module Primitive::Symmetric::Cipher::Authenticated::GCM where

parameter
  /** Key size */
  type K : #
  type constraint (fin K)

  /** Size of initialization vector */
  type IV : #
  type constraint (64 >= width IV, IV >= 1)

  /** Size of additional authenticated data */
  type AAD  : #
  type constraint (64 >= width AAD)

  /** Size of authentication tag */
  type T : #
  type constraint (128 >= T, T >= 64)

  /** Block encryption function */
  E : [K] -> [128] -> [128]

/**
 * GCM encryption function
 *
 * Maintaining this API for backwards compatability, but `GCM-AE` is recommended for
 * more precise spec adherence.
 */
gcmEnc :
  {n} (2^^39 - 256 >= n) =>
      { key : [K], iv : [IV], aad : [AAD], pt : [n] } -> { ct : [n], tag : [T] }
gcmEnc input = { ct = C, tag = T }
  where (C,T) = GCM_AE input.key input.iv input.pt input.aad

/**
 * GCM-AE Function, [NISTSP800-38D] Section 7.1, Algorithm 4. This provides
 * authenticated encryption.
 */

GCM_AE : { P } (fin P, P <= 2^^39 - 256 ) // This constraint comes from [NISTSP800-38D]
 => [K] -> [IV] -> [P] -> [AAD] -> ([P], [T])
GCM_AE k iv p a = (C, T)
  where
    // Set names to match the spec
    CIPHk = E k
    len_IV = `IV
    len_A = `AAD
    len_P = `P

    H = CIPHk 0
    type s = IV %^ 128  // Equivalently: 128 * IV /^ 128 - IV
    J0 = if len_IV == 96 then coerceSize iv # (0 : [31]) # (1 : [1])
         else GHASH`{IV /^ 128 + 1} H (iv # (0 : [s + 64]) # (len_IV: [64]))
    C = GCTR CIPHk (inc`{32} J0) p
    // Why is this on the value P and not the type / length `P? Ditto for A.
    type u = P %^ 128 // Equivalently: 128 * P /^ 128 - O
    type v = AAD %^ 128 // Equivalently: 128 * A /^ 128 - A
    S = GHASH`{AAD/^ 128 + P /^ 128 + 1}
            H (a # (0 : [v]) # C # (0 : [u]) # (len_A : [64]) # (len_P : [64]))
    T = MSB`{T} (GCTR CIPHk J0 S)

/**
 * Property demonstrating equivalence between `gcmEnc` and `GCM_AE`.
 */
 property encryptionApiEquivProperty key iv pt aad = GCM_AE key iv pt aad == (output.ct, output.tag)
    where
      input = { key=key, iv=iv, pt=pt, aad=aad }
      output = gcmEnc input

/**
 * GCM decryption function.
 *
 * Maintaining this API for backwards compatibility, but `GCM-AD` is recommended
 * for more precise spec adherence.
 */
gcmDec :
  {n} (2^^39 - 256 >= n) =>
  { key : [K], iv  : [IV], aad : [AAD], ct  : [n], tag : [T] } ->
  { valid : Bool, pt : [n] }
gcmDec input = case (GCM_AD input.key input.iv input.ct input.aad input.tag) of
    Some pt -> {valid = True, pt = pt}
    None    -> {valid = False, pt = 0}


/**
 * GCM-AD Function, [NISTSP800-38D] Section 7.2, Algorithm 5. This provides
 * authenticated decryption.
 */

GCM_AD : { C }
    ( fin C, C <= 2^^39 - 256 )  // This constraint comes from [NISTSP800-38D]
 => [K] -> [IV] -> [C] -> [AAD] -> [T] -> Option [C]
GCM_AD key iv ct aad tag =
  if tag == T'
  then Some P
  else None
  where
    CIPHk = E key
    len_IV = `IV
    len_A = `AAD
    len_C = `C

    H = CIPHk 0
    type s = IV %^ 128  // Equivalently: 128 * IV /^ 128 - IV
    J0 = if len_IV == 96 then coerceSize iv # (0 : [31]) # (1 : [1])
         else GHASH`{IV /^ 128 + 1} H (iv # (0 : [s + 64]) # (len_IV : [64]))
    P = GCTR CIPHk (inc`{32} J0) ct
    type u = C %^ 128 // Equivalently: 128 * C /^ 128 - C
    type v = AAD %^ 128 // Equivalently: 128 * A /^ 128 - A
    S = GHASH`{AAD /^ 128 + C /^ 128 + 1}
            H (aad # (0 : [v]) # ct # (0 : [u]) # (len_A : [64]) # (len_C : [64]))
    T' = MSB`{T} (GCTR CIPHk J0 S)

/**
 * Property demonstrating equivalence between `gcmDec` and `GCM_AD`.
 */
 property decryptionApiEquivProperty key iv ct aad tag = success
    where
      output = gcmDec { key=key, iv=iv, ct=ct, aad=aad, tag=tag}
      success = case GCM_AD key iv ct aad tag of
        Some ae_pt -> output.valid && (ae_pt == output.pt)
        None       -> ~output.valid

/**
 * Multiplication Operation on Blocks, [NISTSP800-38D] Section
 * 6.3, Algorithm 1. This is optimized to use Cryptol's built-in `pmult` and
 * `pmod` functions. This operation is described using little-endian
 * notation, hence the `reverse`s.
 */

(•) : [128] -> [128] -> [128]
(•) X Y = reverse (pmod (pmult (reverse X) (reverse Y))
                        <| 1 + x + x^^2 + x^^7 + x^^128|>)

/**
 * Multiplication Operation on Blocks, [NISTSP800-38D] Section
 * 6.3. This matches the spec very closely.
 */

mult : [128] -> [128] -> [128]
mult X Y = last Z
  where
    R = 0b11100001 # (0 : [120])
    Z = [0] # [ if [xi] == 0 then Zi else Zi ^ Vi
              | Zi <- Z
              | xi <- X
              | Vi <- V ]
    V = [Y] # [ if LSB`{1} Vi == 0 then Vi >> 1 else (Vi >> 1) ^ R
              | Vi <- V ]
/**
 * Property demonstrating equivalence between `mult` and `•`.
 */
property multEquivProperty X Y = mult X Y == X • Y

/**
 * GHASH Function, [NISTSP800-38D] Section 6.4, Algorithm 2.
 */

GHASH : {m} (fin m) => [128] -> [m * 128] -> [128]
GHASH H X = last Y
  where Y = [0] # [ (Yi ^ Xi) • H | Yi <- Y | Xi <- groupBy`{128} X ]

/**
 * The output of incrementing the right-most s bits of the bit
 * string X, regarded as the binary representation of an integer, by
 * 1 modulo 2s, [NISTSP800-38D] Sections 4.2.2 and 6.2. Care was
 * taken here to ensure `s` could be zero.
 */

inc : {s, a} (fin s, fin a, a >= s) => [a] -> [a]
inc X = MSB`{a-s} X # (LSB`{s} X + take (1 : [max s 1]))


/**
 * The bit string consisting of the s right-most bits
 * of the bit string X, [NISTSP800-38D] Section 4.2.2.
 */

LSB : {s, a} (fin s, fin a, a >= s) => [a] -> [s]
LSB X = drop X

/**
 * The bit string consisting of the s left-most bits of
 * the bit string X, [NISTSP800-38D] Section 4.2.2.
 */

MSB : {s, a} (fin s, a >= s) => [a] -> [s]
MSB X = take X

/**
 * GCTR Function, [NISTSP800-38D] Section 6.5, Algorithm 3.
 */

GCTR : {a} (fin a) => ([128] -> [128]) -> [128] -> [a] -> [a]
GCTR CIPHk ICB X = Y
  where
    Y = X ^ take`{a} (join (map CIPHk CB))
    CB = iterate inc`{32} ICB

coerceSize :  {m,n,a} (fin m, fin n) => [m]a -> [n]a
coerceSize xs = assert (`m == `n) "coerceSize: size mismatch" [xs@i | i <- [0..<n] ]
