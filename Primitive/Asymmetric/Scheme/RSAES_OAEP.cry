/* This module implements an RSA encryption scheme
   with the EME-OAEP encoding method described in 7.1 of

   PKCS #1: RSA Cryptography Specifications Version 2.2

   See also:
   https://tools.ietf.org/html/rfc8017

   Copyright (c) 2018, Galois Inc.
   www.cryptol.net
   You can freely use this source code for educational purposes.
*/

module Primitive::Asymmetric::Scheme::RSAES_OAEP where

import Primitive::Asymmetric::Cipher::RSA

// TODO: COmment all of the prime (') versions of the functions that take an
// explicit seed (as "seed" is defined in the OAEP spec), rather than a seed to
// random.

parameter
  type k : #
  type constraint (fin k, k >= 1)

  type hLen : # // Number of octets returned by chosen hash function
  type constraint (fin hLen, hLen >= 1)

  hash : {a} (2 * hLen >= width (8 * a) ) => [a][8] -> [8 * hLen]

type KeySize = k * 8

RSAES_OAEP_ENCRYPT' : {l,mLen}
                    (fin l, fin mLen
                    , l>=0
                    , 2 * hLen >= width (8 * l) // Required for use of hash
                    , 2 * hLen >= width (8 * ( k - hLen + 3)) // Required for use of hash in MGF
                    , k >= mLen+2*hLen+2
                    , 2^^32*hLen >= k - hLen - 1 // Required for MGF1
                    )
                    => [hLen][8] // Seed for random number
                    -> [mLen][8]
                    -> [l][8]
                    -> [KeySize]
                    -> [KeySize]
                    -> (Bit, [k][8])
RSAES_OAEP_ENCRYPT' seed M L n e = if success then (True, I2OSP`{k} c) // Return k-octet cipher text
                                              else zero
                    where
                     EM = EME_OAEP_encode' seed (M, L)   // Pad message M with optional label L to k octets
                     m  = (zero # OS2IP EM) : [KeySize]  // Take k-octet padded message EM to int of width KeySize
                     (success, c)  = RSAEP ((n, e), m)   // Encrypt integer m

RSAES_OAEP_ENCRYPT : {l,mLen}
                   (fin l, fin mLen
                   , l>=0
                   , 2 * hLen >= width (8 * l) // Required for use of hash
                   , 2 * hLen >= width (8 * ( k - hLen + 3)) // Required for use of hash in MGF
                   , k >= mLen+2*hLen+2
                   , 2^^32*hLen >= k - hLen - 1 // Required for MGF1
                   )
                   => [256] // Seed for random number
                   -> [mLen][8]
                   -> [l][8]
                   -> [KeySize]
                   -> [KeySize]
                   -> (Bit, [k][8])
RSAES_OAEP_ENCRYPT rand M L n e = RSAES_OAEP_ENCRYPT' seed M L n e
                   where
                    seed = random rand : [hLen][8]


RSAES_OAEP_ENCRYPT_INTEGER : {l,mLen}
                           (fin l, fin mLen
                           , l>=0
                           , 2 * hLen >= width (8 * l) // Required for use of hash
                           , 2 * hLen >= width (8 * ( k - hLen + 3)) // Required for use of hash in MGF
                           , k >= mLen+2*hLen+2
                           , 2^^32*hLen >= k - hLen - 1 // Required for MGF1
                           )
                           => [hLen][8] // Seed for random number
                           -> Integer
                           -> Integer
                           -> Integer
                           -> Integer
                           -> Integer
RSAES_OAEP_ENCRYPT_INTEGER seed M L n e = c // Return Integer cipher text
                           where
                            m = EME_OAEP_encode_integer`{l, mLen} seed (M, L)  // Pad and convert to Integer
                            c  = rsaEncrypt (m, e, n)   // Encrypt integer m

/*
encrypt_eq : {l,mLen}
           (fin l, fin mLen
           , l>=0
           , 2 * hLen >= width (8 * l) // Required for use of hash
           , 2 * hLen >= width (8 * ( k - hLen + 3)) // Required for use of hash in MGF
           , k >= mLen+2*hLen+2
           , 2^^32*hLen >= k - hLen - 1 // Required for MGF1
           )
           => [256] // Seed for random number
           -> [mLen][8]
           -> [l][8]
           -> [KeySize]
           -> [KeySize]
           -> Bit
property encrypt_eq rand M L n e =
  (toInteger (join (RSAES_OAEP_ENCRYPT rand M L n e))) ==
  (RSAES_OAEP_ENCRYPT_INTEGER`{l, mLen} (toInteger rand)
                                        (toInteger (join M))
                                        (toInteger (join L))
                                        (toInteger n)
                                        (toInteger e))
                                        */


RSAES_OAEP_DECRYPT : {l}
                   (fin l
                   , l>=0
                   , 2 * hLen >= width (8 * l) // Required for use of hash
                   , 2 * hLen >= width (8 * (k - hLen + 3)) // Required for use of hash in MGF
                   , k >= 2 * hLen + 2
                   , 2^^32*hLen >= k - hLen - 1 // Required for use of MGF1
                   )
                   => [k][8]
                   -> [l][8]
                   -> [KeySize]
                   -> [KeySize]
                   -> (Bit, [k - hLen - 1][8], [width (k - hLen - 1)])
RSAES_OAEP_DECRYPT C L n d = if c < 0 \/ c >= n \/ (~success) then zero
                             else M
                   where
                    c             = OS2IP C
                    (success, m)  = RSADP ((n,d),c)
                    EM            = I2OSP`{k} m
                    M             = EME_OAEP_decode (EM, L)

RSAES_OAEP_DECRYPT_INTEGER : {l}
                           (fin l
                           , l>=0
                           , 2 * hLen >= width (8 * l) // Required for use of hash
                           , 2 * hLen >= width (8 * (k - hLen + 3)) // Required for use of hash in MGF
                           , k >= 2 * hLen + 2
                           , 2^^32*hLen >= k - hLen - 1 // Required for use of MGF1
                           )
                           => Integer
                           -> Integer
                           -> Integer
                           -> Integer
                           -> (Bit, Integer, Integer)
RSAES_OAEP_DECRYPT_INTEGER C L n d = if C < 0 \/ C >= n then zero else M
                           where
                            m = rsaDecrypt (C, d, n)
                            M  = EME_OAEP_decode_integer`{l} (m, L)

// TODO: Test
/*
decrypt_eq : {l}
           (fin l
           , l>=0
           , 2 * hLen >= width (8 * l) // Required for use of hash
           , 2 * hLen >= width (8 * (k - hLen + 3)) // Required for use of hash in MGF
           , k >= 2 * hLen + 2
           , 2^^32*hLen >= k - hLen - 1 // Required for use of MGF1
           )
           => [k][8]
           -> [l][8]
           -> [KeySize]
           -> [KeySize]
           -> Bit
decrypt_eq C L n d = (toInteger (join m_bv), toInteger p_bv) == (m, p)
  where
    (m_bv, p_bv) = RSAES_OAEP_DECRYPT C L n d
    (m, p) = RSAES_OAEP_DECRYPT_INTEGER`{l} (toInteger (join C))
                                            (toInteger (join L))
                                            (toInteger n)
                                            (toInteger d)
                                            */

RSAES_OAEP_Correct : {l,mLen}
                   (fin l, fin mLen
                   , 2 * hLen >= width (8 * l) // Required for use of hash
                   , 2 * hLen >= width (8 * (k - hLen + 3)) // Required for use of hash in MGF
                   , k >= mLen+2*hLen+2
                   , 2^^32*hLen >= k - hLen - 1 // Required for use of MGF1
                   )
                   => [256] // Seed for random number
                   -> [l][8]
                   -> [mLen][8]
                   -> [KeySize]
                   -> [KeySize]
                   -> [KeySize]
                   -> Bit
property RSAES_OAEP_Correct r l m n e d = (RSAES_OAEP_DECRYPT (RSAES_OAEP_ENCRYPT r m l n e).1 l n d).1 == m#(zero:[_][8])



EME_OAEP_encode : {l,mLen}
         (fin l,fin mLen
         , l >= 0
         , 2 * hLen >= width (8 * l) // Required for using hash
         , 2 * hLen >= width (8 * ( k - hLen + 3)) // Required for using hash in MGF
         , k >= mLen + 2 * hLen + 2
         , 2^^32*hLen >= k - hLen - 1 // Required use of MGF1
         )
         => [256] // Seed for random number
         -> ([mLen][8], [l][8])
         -> [k][8]
EME_OAEP_encode rseed (M,L) = EME_OAEP_encode' seed (M,L)
         where
          seed = random rseed : [hLen][8]

EME_OAEP_encode_integer : {l, mLen}
         (fin l,fin mLen
         , l >= 0
         , 2 * hLen >= width (8 * l) // Required for using hash
         , 2 * hLen >= width (8 * ( k - hLen + 3)) // Required for using hash in MGF
         , k >= mLen + 2 * hLen + 2
         , 2^^32*hLen >= k - hLen - 1 // Required use of MGF1
         )
         => [hLen][8]
         -> (Integer, Integer)
         -> Integer
EME_OAEP_encode_integer seed (M, L) = toInteger (OS2IP EM)
                        where
                          // TODO: Checks that these fit?  Either in constraints
                          // or at runtime?
                          M_bv = split`{mLen} ((fromInteger M) : [mLen * 8])
                          L_bv = split`{l} ((fromInteger L) : [l * 8])
                          EM = EME_OAEP_encode'`{l, mLen} seed (M_bv, L_bv)


EME_OAEP_decode : {l}
         (fin l
         , l>=0
         , 2*hLen >= width (8 * l) // Required for using hash
         , 2*hLen >= width (8 * ( k - hLen + 3)) // Required for using hash in MGF
         , k >= 2 * hLen + 2
         , 2^^32*hLen >= k - hLen - 1 // Required for using MGF1
         ) => ([k][8], [l][8]) -> (Bit, [k - hLen - 1][8], [width (k - hLen - 1)])
EME_OAEP_decode (EM,L) = if Y != zero then zero
                         | lHash' != lHash then zero
                         else (True,Mpadded,mLen)
                where
                  Y          = head EM
                  maskedSeed = take`{hLen} (drop`{1} EM)
                  maskedDB   = drop`{hLen+1} EM
                  seedMask   = MGF1`{maskLen=hLen} maskedDB
                  seed       = seedMask ^ maskedSeed
                  dbMask     = MGF1`{maskLen=k-hLen-1} seed
                  DB         = maskedDB ^ dbMask // lHash' # (zero:[_][8]) # [(1:[8])] # M
                  lHash'     = take`{hLen} DB // This should equal hash L
                  lHash      = split (hash L) : [_][8]
                  (Mpadded,mLen) = extractMsg DB // Original msg is take`{mLen} Mpadded

// TODO: Is there something better to return an int that doesn't include the
// padding?
EME_OAEP_decode_integer : {l}
         (fin l
         , l>=0
         , 2*hLen >= width (8 * l) // Required for using hash
         , 2*hLen >= width (8 * ( k - hLen + 3)) // Required for using hash in MGF
         , k >= 2 * hLen + 2
         , 2^^32*hLen >= k - hLen - 1 // Required for using MGF1
         ) => (Integer, Integer) -> (Bit, Integer, Integer)
EME_OAEP_decode_integer (EM,L) = (success,
                                  toInteger (join Mpadded_bv),
                                  toInteger mLen_bv)
                where
                  EM_bv = split`{k} ((fromInteger EM) : [k * 8])
                  L_bv = split`{l} ((fromInteger L) : [l * 8])
                  (success, Mpadded_bv, mLen_bv) = EME_OAEP_decode (EM_bv, L_bv)

private
    extractMsg : {a} (fin a, a >= 1) =>  [a][8] -> ([a][8],[width a])
    extractMsg DB = (Mpadded, mLen)
                where
                 init    = {removedPad = False,
                            padMsg     = DB,
                            idx        = (`a:[width a])}
                 ys      = [init] # [ if (~y.removedPad /\ x==(1:[8]) )
                                          then {removedPad = True,
                                                padMsg     = (tail y.padMsg)#(zero:[1][8]),
                                                idx        = y.idx - 1}
                                          | y.removedPad
                                          then y
                                          else {removedPad = False,
                                                padMsg     = (tail y.padMsg)#(zero:[1][8]),
                                                idx        = y.idx - 1}
                                    | x <- DB
                                    | y <- ys ]
                 Mpadded = (ys!0).padMsg
                 mLen    = (ys!0).idx

    EME_OAEP_encode' : {l,mLen}
             (fin l,fin mLen
             , l >= 0
             , 2 * hLen >= width (8 * l) // Required for using hash
             , 2 * hLen >= width (8 * ( k - hLen + 3)) // Required for using hash in MGF
             , k >= mLen + 2 * hLen + 2
             , 2^^32*hLen >= k - hLen - 1 // Required use of MGF1
             )
             => [hLen][8]
             -> ([mLen][8], [l][8])
             -> [k][8]
    EME_OAEP_encode' seed (M,L) = (zero : [1][8]) # maskedSeed # maskedDB // value of EM
             where
              lHash      = split (hash L) : [hLen][8]
              PS         = (zero:[(k-mLen-2*hLen-2)][8]) // This may be (zero:[0][8])
              DB         = lHash # PS # [(1:[8])] # M
              dbMask     = MGF1`{maskLen=(k-hLen-1)} seed
              maskedDB   = DB ^ dbMask
              seedMask   = MGF1`{maskLen=hLen} maskedDB
              maskedSeed = seed ^ seedMask



MGF1 : {maskLen,l,counterMax}
       (fin hLen, fin l, fin maskLen
       , hLen >= 1
       , maskLen >= 1
       , 2*hLen >= width (8 * (4 + l))
       , 2^^32 * hLen >= maskLen
       , counterMax == maskLen/^hLen - 1 // (ceiling maskLen/hLen) - 1
       )
       => [l][8] // MGF Seed
       -> [maskLen][8]
MGF1 mgfSeed = take`{maskLen} Ts
     where

      Cs = map (\counter -> I2OSP`{xLen=4} counter) ([0..counterMax]:[_][32])
      Ts = join [ split (hash (mgfSeed # c)) : [_][8] | c <- Cs]


MGF1' : {seedLen, maskLen} (fin seedLen, fin maskLen, hLen == 48, seedLen == 48) => [seedLen][8] -> [maskLen][8]
MGF1' seed = take (join [ split (hash (seed # (split c))) | c <- [(0 : [32]) ...] ])

PSS_mgf1_encode : {emLen} (fin emLen, emLen == 128, hLen == 48, emLen >= 2 * hLen + 2) => [hLen][8] -> [hLen][8] -> [emLen][8]
PSS_mgf1_encode mHash salt = EM'
  where
    M' = (zero : [8][8]) # mHash # salt 
    H = split (hash M')
    DB = (zero : [emLen - 2 * hLen - 2][8]) # [0x01] # salt
    dbMask = MGF1' H
    maskedDB = DB ^ dbMask
    EM = maskedDB # H # [0xbc]
    EM' = update EM 0 ((EM @ 0) && 0x7f)

PSS_mgf1_verify : {emLen} (fin emLen, emLen == 128, hLen == 48, emLen >= 2 * hLen + 2) => [hLen][8] -> [emLen][8] -> Bit
PSS_mgf1_verify mHash EM = 0xbc == byte_0xbc /\ 0 == (maskedDB @ 0) && 0x80 /\ (zero : [emLen - 2 * hLen - 2][8]) == padding /\ 0x01 == byte_0x01 /\ H == H'
  where
    (maskedDB # H # [byte_0xbc]) = EM
    dbMask = MGF1' H
    DB = maskedDB ^ dbMask
    DB' = update DB 0 ((DB @ 0) && 0x7f)
    padding # [byte_0x01] # salt = DB'
    M' = (zero : [8][8]) # mHash # salt 
    H' = split (hash M')

RSA_sign : {emLen} (fin emLen, emLen == 128, hLen == 48, emLen >= 2 * hLen + 2) => [hLen][8] -> [hLen][8] -> Integer -> Integer -> Integer
RSA_sign mHash salt d n = (exp (integerFromBV (join (PSS_mgf1_encode mHash salt))) d) % n

RSA_verify : {emLen} (fin emLen, emLen == 128, hLen == 48, emLen >= 2 * hLen + 2) => [hLen][8] -> Integer -> Integer -> Integer -> Bit
RSA_verify mHash sig e n = sig < n /\ PSS_mgf1_verify mHash (split (integerToBV ((exp sig e) % n)))


exp : Integer -> Integer -> Integer
exp = (^^)

bn_mont_n0 : {a} (fin a) => [a][64] -> [64]
bn_mont_n0 n = undefined

integerToBV : {m} (fin m) => Integer -> [m]
integerToBV x = fromInteger x

integerFromBV : {m} (fin m) => [m] -> Integer
integerFromBV x = toInteger x

integerModulusFromBV : {m} (fin m) => [m] -> Integer
//integerModulusFromBV x = if x == 0 then 1 else (toInteger x)
integerModulusFromBV x = if (integerFromBV x) == 0 then 1 else (integerFromBV x)



is_num_bits_bn : {m,w} (fin m, fin w, m <= w) => [w] -> Bit
is_num_bits_bn x = if `m == `w
  then x @ 0
  else take`{w - m} x == 0 /\ x @ (`w - `m)
