/**
 * References:
 * [SP-800-56Ar3]: Elaine Barker, LilyChen, Allen Roginsky, Apostol Vassilev,
 *    Richard Davis. Recommendation for Pair-Wise Key-Establishment Schemes
 *    Using Discrete Logarithm Cryptography. (National Institute of Standards
 *    and Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST
 *    SP 800-56A Revision 3. April 2018.
 *    @see https://doi.org/10.6028/NIST.SP.800-56Ar3
 * [SP-800-186]: Lily Chen, Dustin Moody, Karen Randall, Andrew Regenscheid,
 *    Angela Robinson. Recommendations for Discrete Logarithm-based Cryptography:
 *    Elliptic Curve Domain Parameters. (National Institute of Standards and
 *    Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST SP
 *    800-186. February 2023.
 *    @see https://doi.org/10.6028/NIST.SP.800-186
 *
 * @copyright Galois, Inc.
 * @author Marcella Hastings <marcella@galois.com>
 *
 */
module Primitive::Asymmetric::Generation::ECDH::Specification where

/**
 * Secure key establishment depends on the arithmetic validity of the domain
 * parameters used by the parties.
 *
 * Instantiation of this interface does not guarantee validity of the domain
 * parameters! Implementors must ensure that the domain parameters correspond
 * to a specifically approved group as specified in [SP-800-186] (or they can
 * rely on a trusted third party to provide assurance that the parameters
 * are approved).
 * [SP-800-56Ar3] Section 5.5.2.
 */
import interface Common::EC::ECInterface as EC

/**
 * An ECC private, or signing, key.
 *
 * A valid private key is an integer that is randomly selected in the
 * interval [1, n-1]. This type can be used to represent either static or
 * ephemeral keys (as defined in [SP-800-56Ar3]).
 *
 * This must be generated with an approved method! This specification does
 * not enforce correct generation.
 *
 * [SP-800-56Ar3] Section 5.6.1.2.
 */
type SigningKey = Z EC::n

/**
 * An ECC public, or verifying, key.
 *
 * A valid public key is a non-identity point on the curve, in the subgroup
 * generated by the base point `G`. It must form a pair with a corresponding
 * `SigningKey`.
 *
 * This must be generated from a valid `SigningKey`! This specification does
 * not enforce correct generation.
 *
 * [SP-800-56Ar3] Section 5.6.1.2.
 */
type VerifyingKey = EC::Point

/**
 * Get assurance of private-key validity.
 *
 * A valid private key is in the interval `[1, n-1]`, where `n` is the order
 * of the base point for the curve.
 * The upper bound is assured by the `SigningKey` type itself.
 *
 * [SP-800-56Ar3] Section 5.6.2.1.2.
 */
signingKeyValid : SigningKey -> Bool
signingKeyValid d = d != 0

/**
 * Check whether the verifying key is fully valid:
 * - It must not be the point at infinity;
 * - It must have the expected representation for an element in the underlying
 *   field;
 * - It must be a point on the correct curve; and
 * - It must have the correct order.
 *
 * [SP-800-56Ar3] Section 5.6.2.3.3.
 */
verifyingKeyFullyValid : VerifyingKey -> Bool
verifyingKeyFullyValid Q = verifyingKeyPartiallyValid Q && correctOrder where
    correctOrder = EC::isInfinity (EC::scmul `EC::n Q)

/**
 * Partially check whether the verifying key is valid:
 * - It must not be the point at infinity;
 * - It must have the expected representation for an element in the underlying
 *   field; and
 * - It must be a point on the correct curve.
 *
 * This routine omits the validation that the point is in the subgroup
 * generated by the base point `G`; it is usually faster than full validation.
 * This should only be used for _ephemeral_ ECC public keys!!
 *
 * [SP-800-56Ar3] Section 5.6.2.3.4.
 */
verifyingKeyPartiallyValid : VerifyingKey -> Bool
verifyingKeyPartiallyValid Q = EC::isValid Q && ~(EC::isInfinity Q)

/**
 * The owner of a key pair needs to make sure it's consistent before using it
 * for key establishment.
 * [SP-800-56Ar3] Section 5.6.2.1.4.
 */
keyPairIsConsistent : SigningKey -> VerifyingKey -> Bool
keyPairIsConsistent d Q = EC::pointEq expectedQ Q where
    expectedQ = EC::scmul (fromZ d) EC::G
