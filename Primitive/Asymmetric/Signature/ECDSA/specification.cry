/*
ECDSA as specified in [FIPS-186-5] Section 6.

@copyright Galois, Inc
@author Marcella Hastings <marcella@galois.com>
*/

module Primitive::Asymmetric::Signature::ECDSA::specification where

import interface Common::EC::ECInterface as EC
import Primitive::Keyless::Hash::SHA2::SHA256 as Hash
import Common::utils(mp_mod_inv)

/**
 * ECDSA signature generation algorithm.
 *
 * This deviates from the original spec in several ways:
 * 1. The per-message secret number `k` is passed as a parameter insteaed of
 *    being generated using an approved procedure.
 *    ⚠️ Warning ⚠️: This deviation means that adherence to this spec cannot
 *    detect a catastrophic secret-number-reuse implementation mistake!
 *    Implementors must manually verify that secret numbers are chosen
 *    according to an approved procedure; are protected from unauthorized
 *    disclosure and modification; and are not reused.
 * 1b. The spec requires that if `r` or `s` are 0 and `k` is not generated
 *    deterministically, then the computation should repeat until a valid `k`
 *    is found. This implementation fails if either value is 0, because Cryptol
 *    cannot produce a new random value for `k`.
 * 2. The spec requires that `k` and its inverse are securely destroyed in
 *    step 10. Cryptol does not have any way to express this. Implementors
 *    must manually verify that they have removed those values from memory.
 * 3. The spec requires the hash function to be passed as an input. In this
 *    implementation, it is fixed to be SHA256 (from the SHA2 family). This is
 *    due to lack of an appropriate hash-function interface, not for any
 *    technical reason. We also introduce the constraint on `m` that ensures
 *    it is short enough to be processable by SHA256.
 * 4. The spec describes the domain parameters as an input to this function.
 *    In this implementation, we encode the domain parameters in the
 *    `ECInterface` included in this module, so they aren't passed explicitly.
 *
 * Inputs:
 * M : [m].     Bit string `M` to be signed.
 * d : Z n. Private key in the interval [1, n-1].
 * k : Z n. per-message secret number in the interval [1, n-1].
 *
 * Outputs:
 * (r, s) : A pair of integers, each in the interval [1, n-1].
 *      or failure (`None`) if:
 *      - the inputs `d` and `k` were not in the correct interval;
 *      - the outputs `r` or `s` were 0 for the given inputs;
 *      - the product `[k]G` is the point at infinity (this is unlikely?
          Impossible?)
 *
 * In all inputs and outputs, `n` is the order of the base point `G` for the
 * elliptic curve specified in the `PFEC` interface.
 */
sign : {m} (fin m, width m < 64) => [m] -> Z EC::n -> Z EC::n -> Option (Z EC::n, Z EC::n)
sign M d k = if inputsInRange then maybe_rs else None
    where
        // Preconditions must hold.
        inputsInRange = (0 != d) && (0 != k)

        // Step 1.
        H = Hash::sha M

        // Step 2a.
        e' = take`{min (width EC::n) Hash::digestSize} H
        // Step 2b.
        // Cryptol's default bitstring-to-integer `toInteger` conversion
        // matches the routine specified in [FIPS-186-5] Appendix B.2.1.
        // We further convert it to an element in `Z n` to support the modular
        // operations later in the protocol.
        e = fromInteger (toInteger e') : Z EC::n

        // Step 3. k is passed as a parameter because Cryptol cannot generate
        // random numbers.

        // Step 4.
        k_inv = mp_mod_inv k

        // Step 5.
        R = EC::scmul (fromZ k) EC::G

        // Steps 6-8. This fails (returns `None`) if `R` is the point at
        // infinity.
        maybe_r = EC::xCoordModOrder R

        // This fails (returns `None`) if `r` or `s` are invalid.
        maybe_rs = case maybe_r of
            // Step 11.
            Some r -> if (r != 0) && (s != 0) then Some (r, s) else None
                where
                    // Step 9.
                    s = (k_inv * (e + r * d))
            None -> None

