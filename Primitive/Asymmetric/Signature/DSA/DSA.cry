module Primitive::Asymmetric::Signature::DSA::DSA where
import Common::mod_arith
import Common::utils

sign : Z q -> Z q -> Z q -> (Z q, Z q)
sign x k z = (r, s)
    where r = ZtoZ`{q=q} (BVtoZ `{p=p}(mod_pow (pv, g', k')))
          pv = ZtoBV `{a=1024} `p
          g' = ZtoBV `{a=1024} g
          k' = ZtoBV `{a=1024} (ZtoZ `{q=q} k)
          s = BVtoZ `{p=q}  (mod_mul (q', (ZtoBV `{a=160}(mp_mod_inv k)), (mod_add(q', mod_mul(q', x', r'), z'))))
          r' = ZtoBV `{a=160} r
          x' = ZtoBV `{a=160} x
          z' = ZtoBV `{a=160} z
          q' = ZtoBV `{a=160} `q


verify : Z p -> Z q -> (Z q, Z q) -> Bit
verify y z (r, s) = ((BVtoZ `{p=q} v) == r)
   where w = (mp_mod_inv s)
         u1 = (zero#mod_mul (q', (ZtoBV z), (ZtoBV w))) :[1024]
         u2 = (zero#mod_mul (q', (ZtoBV r), (ZtoBV w))) :[1024]
         v = mod_mul (pv, gu1, yu2)
         gu1 =  mod_pow(pv, g', u1)
         yu2 =  mod_pow(pv, y', u2)
         pv = ZtoBV `{a=1024} `p
         g' = ZtoBV `{a=1024} g
         y' = ZtoBV `{a=1024} y
         q' = ZtoBV `{a=160} `q


parameter

    type p : #
    type constraint Constraints p

    g : Z p

    type q : #

    type constraint (fin q, isOdd q, q >= 4)


private

    type constraint Constraints a = (fin a, isOdd a, a >= 4)


//property sign_correct x k z = (verify g^x z (sign x k z) ) == True
