/**
 * WOTS+: One-Time Signatures.
 *
 * This signature primitive is used in the XMSS signature scheme. In WOTS+,
 * a private key can be used to sign any message, but each private key can
 * be used only once.
 * Warning: If a private key is used to sign two different messages, the scheme
 * becomes insecure! Cryptol cannot protect against this failure mode!
 *
 * References:
 * [RFC-8391]: Andreas Huelsing, Denis Butin, Stefan-Lukas Gazdag, Joost
 *     Rijneveld, and Aziz Mohaisen. XMSS: eXtended Merkle Signatuer Scheme.
 *     Internet Requests for Comments (RFC) 8391. May 2018.
 *     @see https://datatracker.ietf.org/doc/rfc8391
 */
module Primitive::Asymmetric::Signature::XMSS::Wots where


parameter
    /**
     * Security parameter.
     * This defines the message length, the length of a private key, the length
     * of a public key, and a signature element (in bytes).
     * [RFC-8391] Section 3.1.1.
     */
    type n : #
    type constraint (fin n)

    /**
     * The Winternitz parameter. This must be either 4 or 16.
     * [RFC-8391] Section 3.1.1.
     */
    type w : #
    type constraint (fin w, w % 4 == 0, w % 12 == 4, w <= 16)

    /**
     * A keyed cryptographic hash function that takes a key and a message.
     * [RFC-8391] Section 3.1.1.1.
     */
    F : [n][8] -> [n][8] -> [n][8]

    /**
     * A pseudorandom function that takes a key and an index.
     * [RFC-8391] Section 3.1.1.1.
     */
    PRF : [n][8] -> [32][8] -> [n][8]

/**
 * A byte is a sequence of 8 bits using big-endian representation.
 * [RFC-8391] Section 2.1.
 */
type Byte = [8]

/**
 * A word is a 32-bit sequence used to define hash addresses.
 * [RFC-8391] Section 2.5.
 */
type Word = [32]

/**
 * A length value.
 * [RFC-8391] Section 3.1.1.
 */
type len_1 = (8 * n) /^ (lg2 w)
/**
 * A length value.
 * [RFC-8391] Section 3.1.1.
 */
type len_2 = (lg2 (len_1 * (w - 1)) / (lg2 w)) + 1
/**
 * The number of `n`-byte string elements in a WOTS+ private key, public key,
 * and signature.
 * [RFC-8391] Section 3.1.1.
 */
type len = len_1 + len_2

/**
 * Address scheme for randomizing hash function calls in the OTS scheme.
 * [RFC-8391] Section 2.5.
 *
 * The address breaks down 7 components, each 1 word long unless specified.
 * 1. Layer address
 * 2-3. Tree address (2 Words)
 * 4. Type (fixed at 0)
 * 5. OTS address
 * 6. Chain address
 * 7. Hash address
 * 8. keyAndMask
 *
 * Note that this isn't defined in terms of the `Word` type because it's
 * operated on by things that require arrays of bytes.
 */
type OTSHashAddress = [8 * 4]Byte

private

    /**
     * Set the hash address word (in the 5th position) in an `OTSHashAddress`.
     * This setter is defined implicitly in the spec.
     * [RFC-8391] Section 2.7.
     */
    setHashAddress : OTSHashAddress -> Word -> OTSHashAddress
    setHashAddress address value =
        take`{6 * 4} address # (split value) # drop`{7 * 4} address

    /**
     * Set the `keyAndMask` word (the last position) in an `OTSHashAddress`.
     * This setter is defined implicitly in the spec.
     * [RFC-8391] Section 2.7.
     */
    setKeyAndMask : OTSHashAddress -> Word -> OTSHashAddress
    setKeyAndMask address value = take`{7 * 4} address # split value

    /**
     * Chaining function that iterates `F` on the input `X`, `s` times.
     */
    chain : [n]Byte -> Word -> Word -> [n]Byte -> OTSHashAddress -> [n]Byte
    chain X i s SEED ADRS = return where
        return = if s == 0 then
                X
            else if i + s > `w - 1 then
                error "Invalid `s` and `i` parameters passed to `chain`"
            else
                tmp'
        tmp = chain X i (s - 1) SEED ADRS

        ADRS' = setHashAddress ADRS (i + s - 1)
        ADRS'' = setKeyAndMask ADRS' 0
        KEY = PRF SEED ADRS''
        ADRS''' = setKeyAndMask ADRS'' 1
        BM = PRF SEED ADRS'''

        tmp' = F KEY (tmp ^ BM)
