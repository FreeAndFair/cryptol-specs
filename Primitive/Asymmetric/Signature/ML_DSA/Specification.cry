/**
 * ML-DSA (CRYSTALS-Dilithium) signature scheme.
 *
 * This provides an algorithm for digital signatures with non-repudiation,
 * designed to be secure against an adversary with a large-scale quantum
 * computer.
 *
 * This executable specification matches the final version of [FIPS-204].
 *
 * References:
 * [FIPS-204]: National Institute of Standards and Technology. Module-Lattice-
 *     Based Digital Signature Standard. (Department of Commerce, Washington,
 *     D.C.), Federal Information Processing Standards Publication (FIPS) NIST
 *     FIPS 204. August 2024.
 *     @see https://doi.org/10.6028/NIST.FIPS.204
 *
 * @copyright Galois Inc
 * @author Marcella Hastings <marcella@galois.com>
 */
module Primitive::Asymmetric::Signature::ML_DSA::Specification where

import Common::OptionUtils(flatMap)
import Common::utils(while)
import Primitive::Keyless::Hash::SHAKE::SHAKE128 as SHAKE128
import Primitive::Keyless::Hash::SHAKE::SHAKE256 as SHAKE256

type Byte = [8]

/**
 * Ring defined as the product of 256 elements in `Z q`, used for NTT.
 * [FIPS-204] Section 2.3 and Section 2.4.1.
 */
type Tq = [256](Z q)

/**
 * Ring of single-variable polynomials over the integers mod `X^256 + 1`.
 * [FIPS-204] Section 2.3 and Section 2.4.1.
 *
 * The `i`th element of this list represents the coefficient for the degree-`i`
 * term.
 */
type R = [256]Integer

/**
 * The ring of single-variable polynomials over the integers mod 2, modulo
 * `X^256 + 1`.
 * [FIPS-204] Section 2.3 and Section 2.4.1.
 *
 * We represent individual elements in `ℤ_2` as bits, so this is just a bit
 * array.
 */
type R2 = [256]

/**
 * Wrapper function around SHAKE256, specifying the length `l` in bytes.
 * [FIPS-204] Section 3.7.
 *
 * The spec also defines a 3-part API for interacting with `H` (`Init`,
 * `Absorb`, `Squeeze`); we simulate this by generating an infinite output
 * and lazily taking things from it for each call to `Squeeze`, as described
 * in the same section.
 */
H : {l, m} (fin m) => [m][8] -> [l][8]
H str = SHAKE256::xofBytes`{8 * l} str

/**
 * Wrapper function around SHAKE128, specifying the length `l` in bytes.
 * [FIPS-204] Section 3.7.
 *
 * The spec also defines a 3-part API for interacting with `G` (`Init`,
 * `Absorb`, `Squeeze`); we simulate this by generating an infinite output
 * and lazily taking things from it for each call to `Squeeze`, as described
 * in the same section.
 */
G : {l, m} (fin m) => [m][8] -> [l][8]
G str = SHAKE128::xofBytes`{8 * l} str

parameter
    /**
     * Modulus defining the ring used throughout the protocol.
     * [FIPS-204] Section 4, Table 1.
     */
    type q = 8380417

    /**
     * Hamming weight of the mask sampled in signing.
     *
     * The spec describes this as "number of ±1s in polynomial `c`", where `c`
     * is the verifier's challenge.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint is drawn from [FIPS-204] Section 7.3, Algorithm 29.
     */
    type τ : #
    type constraint (τ <= 64)

    /**
     * Collision strength of the commitment hash `c~` component of a signature.
     * [FIPS-204] Section 4, Table 1.
     */
    type λ : #

    /**
     * Coefficient range of the commitment mask `y` used in signing.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint, which claims that γ1 must be a power of 2, is drawn
     * from [FIPS-203] Section 7.2, Algorithm 27.
     */
    type γ1 : #
    type constraint (2 ^^ (lg2 γ1) == γ1)

    /**
     * Low-order rounding range; this defines how to round the signer's
     * commitment `w`.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint is drawn from [FIPS-204] Section 7.4. The primary
     * constraint we wish to encode is that `2 * γ2` divides `q - 1`;
     * to express this, we must also require that γ2 is non-zero.
     */
    type γ2 : #
    type constraint (γ2 > 0, (q - 1) % (2 * γ2) == 0)

    /**
     * Dimensions of the matrix `A`, which is part of the public key.
     * [FIPS-204] Section 4, Table 1.
     */
    type k : #
    type ell : #
    type constraint (fin k, fin ell, k > 0, width k <= 8)

    /**
     * Private key range; the private key is a polynomial whose coefficients
     * are all in a range defined by η.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint (that η must be in the set {2, 4}) is drawn from
     * [FIPS-204] Section 7.1, Algorithm 15.
     */
    type η : #
    type constraint (η % 2 == 0, 2 <= η, η <= 4)

    /**
     * Maximum Hamming weight for the hint component of a signature.
     * [FIPS-204] Section 4, Table 1.
     */
    type ω : #
    type constraint (fin ω, width ω <= 8)

/**
 * A 512th root of unity in `Z_q`.
 * [FIPS-204] Section 4, Table 1.
 */
type ζ = 1753

/**
 * Number of dropped bits from `t` (this compresses the public key for
 * a performance optimization).
 * [FIPS-204] Section 4, Table 1.
 */
type d = 13

/**
 * Allowable error range for signature components. In signing, this is used to
 * determine if a candidate signature is valid.
 * [FIPS-204] Section 4, Table 1.
 */
type β = η * τ

/**
 * Generate an element in the integers mod `q` or a failure indicator.
 * [FIPS-204] Section 7.1, Algorithm 14.
 */
CoeffFromThreeBytes : Byte -> Byte -> Byte -> Option (Z q)
CoeffFromThreeBytes b0 b1 b2 = maybe_z where
    // Steps 1 - 4.
    b2' = if b2 > 127 then b2 - 128 else b2

    // We have to explicitly expand the byte strings to support the
    // operations in the next step. 32 bits gives us plenty of space.
    [bq0, bq1, bq2'] = map zext`{32} [b0, b1, b2']

    // Step 5.
    z = 2^^16 * bq2' + 2^^8 * bq1 + bq0

    // Step 6 - 7. We have to convert `z` into `Z q` manually in the successful
    // case -- note that we can't do it sooner because otherwise the condition
    // is moot.
    maybe_z = if z < `q then Some (toZ z) else None

    toZ : [32] -> Z q
    toZ b = fromInteger (toInteger b)

/**
 * Generate an element of {-η, -η + 1, ..., η} or a failure indicator.
 * [FIPS-204] Section 7.1, Algorithm 15.
 */
CoeffFromHalfByte : [4] -> Option Integer
CoeffFromHalfByte b =
    if (`η == 2) && (b < 15) then Some (2 - (toInteger b % 5))
    else
        if (`η == 4) && (b < 9) then Some (4 - toInteger b)
        else None

/**
 * Encode a polynomial vector `h` with binary coefficients into a byte string.
 * [FIPS-204] Section 7.1, Algorithm 20.
 */
HintBitPack : [k]R2 -> [ω + k]Byte
HintBitPack h = yFinal where
    // Step 1.
    y0 = zero : [ω + k]Byte
    // Step 2.
    Index0 = 0
    // Steps 3 - 11. This builds a list with all the intermediate values of
    // `y` and `Index`...
    yAndIndex = [(y0, Index0)] # [ (y'', Index') where
            // Steps 5 - 8.
            (y', Index') = if (h @i @j) != 0 then
                    (update y Index j, Index + 1)
                else (y, Index)

            // Step 10.
            y'' = if j == 255 then
                    update y' (`ω + i) Index'
                else y'
        | (y, Index) <- yAndIndex
        // Step 3 - 4.
        | i <- [0..k-1], j <- [0..255]
    ]
    // Step 12. ...we return the last `y`.
    (yFinal, _) = yAndIndex ! 0

/**
 * This diverges slightly from the spec:
 * - To simplify updating `h`, we treat it as a single array of size `256k`.
 *   We separate it into the correct `[k]R2` representation in the final step.
 *   We access the array in "the natural way" -- that is, in Step 12, the
 *   element `h[i]_y[Index]` is at index `i * k + y[Index]` in our array.
 */
HintBitUnpack : [ω + k]Byte -> Option ([k]R2)
HintBitUnpack y = h___ where
    // Useful rename for annotation functions that operate over the stateful
    // pair of `h` and `Index` used across this function.
    type Pair = ([k * 256], Byte)

    // Step 1.
    h0 = zero : [k * 256]
    // Step 2.
    Index0 = 0

    // Step 3. Construct a list comprising the values of `h` and `Index`
    // at the end of each iteration of the loop in Steps 3 - 15.
    hAndIndex = [Some (h0, Index0)] # [
            flatMap (Step4_5 i) maybe_hAndIndex
        | maybe_hAndIndex <- hAndIndex
        | i <- [0..k-1]
    ]

    // Steps 4 - 5.
    Step4_5 : Byte -> Pair -> Option Pair
    Step4_5 i (h, Index) = if (y@(`ω + i) < Index) || (y@(`ω + i) > `ω) then
            None
        else Step6_15 (h, Index) i

    // Steps 6 -15
    Step6_15 : Pair -> Byte -> Option Pair
    Step6_15 (h, Index) i = result15 where
        // Step 6.
        First = Index
        result15 = Step7_14 (h, Index) i First

    // Steps 7 - 14.
    Step7_14 : Pair -> Byte -> Byte -> Option Pair
    Step7_14 (h, Index) i First =
        if Index < (y@(`ω + i)) then
            // The `/\` is a short-cutting `and`, equivalent to the nested `if`
            // statements in the spec.
            if ((Index > First) /\ (y@(Index - 1) >= y@Index)) then None
            // Recursive call is equivalent to continuing the loop.
            // The constants `i` and `First` do not change between iterations.
            else Step7_14
                (update h (i*`k + y@Index) 1,
                Index + 1)
                i First
        // If the loop condition is no longer true, return the current values
        // of `h` and `Index`.
        else Some (h, Index)

    // Get the values of `h` and `Index` after the loop in Steps 3 - 15.
    maybe_hAndIndex = hAndIndex ! 0

    // This helper function uses recursion to read any leftover bytes in the
    // first `ω` bytes of `y`; it returns an error if any of them are non-zero.
    checkZero idx =
        if idx > (`ω - 1) then True
        else if (y@idx != zero) then False
        else checkZero (idx + 1)

    // Step 16 - 20.
    h___ = flatMap
        (\(h, Index) -> if (checkZero Index) then Some (split`{k} h)
            else None
        )
        maybe_hAndIndex

/**
 * Verify that `HintBitUnpack` is the reverse of `HintBitPack`.
 *
 * This takes a list of indexes indicating the non-zero elements and constructs
 * a valid, sparse `h` -- rejection sampling was not a valid option because
 * sparse-enough `h`s were too rare.
 * ```repl
 * :check HintPackingInverts
 * ```
 */
HintPackingInverts : {w} (w <= ω) => [w][lg2 (256 * k)] -> Bit
property HintPackingInverts h_Indexes =
    case HintBitUnpack (HintBitPack h) of
        Some h' -> h == h'
        None -> False
    where
        // build h out of h_indexes:
        h = split`{k} [if elem idx h_Indexes then 1 else 0 | idx <- [0..(256 * k) - 1]]

/**
 * Sample a polynomial in the ring `Tq`.
 * [FIPS-204] Section 7.3, Algorithm 30.
 */
RejNTTPoly : [32]Byte -> Tq
RejNTTPoly ρ = a_hat where
    // Step 2 - 3.
    ctx0 = G ρ

    // Step 4, 11. The `take` here replaces the loop condition.
    a_hat = take`{256} (sample ctx0)

    sample : [inf][8] -> [inf](Z q)
    sample GSqueeze = a_hat' where
        // Step 5. This pops the first 3 bytes off the pseudorandom stream.
        (s, ctx) = splitAt`{3} GSqueeze

        // Step 6.
        a_hat_j = CoeffFromThreeBytes (s@0) (s@1) (s@2)

        // Step 7 - 9. The recursive call here replaces the `while` loop.
        a_hat' = case a_hat_j of
            Some aj -> [aj] # (sample ctx)
            // In the spec, the sample `a_hat_j` is always added to the list,
            // and `j` is only increased if the sample was not rejected (so a
            // rejected value is overwritten in the next iteration). Here,
            // we only add `a_hat_j` if it's valid.
            None -> sample ctx

/**
 * Sample an element in `R` with coefficients in the range [-η, η].
 * [FIPS-204] Section 7.3, Algorithm 31.
 */
RejBoundedPoly: [66]Byte -> R
RejBoundedPoly ρ = a where
    // Steps 2 - 3.
    ctx0 = H ρ

    // Step 4, 17. The `take` replaces the loop condition.
    a = take`{256} (sample ctx0)

    sample : [inf][8] -> [inf]Integer
    sample HSqueeze = a' where
        // Step 5. This pops one byte off the pseudorandom stream.
        ([z] # ctx) = HSqueeze

        // Step 6 - 8. We use Cryptol-native functions instead of dividing
        // and modding `z`. See `TakeAndDropAreDivAndMod` for the equivalence.
        z0 = CoeffFromHalfByte (drop`{4} z)
        z1 = CoeffFromHalfByte (take`{4} z)

        // Step 8 - 15. The recursive calls replace the `while` loop.
        // In order to make the types work, we have to mash the two conditions
        // together and make exactly one recursive call.
        a' = case z0 of
            Some z0' -> case z1 of
                Some z1' -> [z0', z1'] # (sample ctx)
                None -> [z0'] # (sample ctx)
            None -> case z1 of
                Some z1' -> [z1'] # (sample ctx)
                None -> sample ctx

/**
 * Given a byte, the `take` function is equivalent to dividing by 16, and the
 * `drop` function is equivalent to taking the value mod 16.
 *
 * We prefer the Cryptol functions because they automatically convert from a
 * byte to a 4-bit value, which we need to call `CoeffFromHalfByte`. Here, we
 * use `zext` pad the 4-bit-vector, so we can compare it to the byte.
 * ```repl
 * :prove TakeAndDropAreDivAndMod
 * ```
 */
TakeAndDropAreDivAndMod : [8] -> Bool
property TakeAndDropAreDivAndMod z = dropIsMod && takeIsDiv where
    dropIsMod = z % 16 == zext (drop`{4} z)
    // Division of bit vectors in Cryptol automatically takes the floor.
    takeIsDiv = z / 16 == zext (take`{4} z)
