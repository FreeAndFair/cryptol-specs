/**
 * ML-DSA (CRYSTALS-Dilithium) signature scheme.
 *
 * This provides an algorithm for digital signatures with non-repudiation,
 * designed to be secure against an adversary with a large-scale quantum
 * computer.
 *
 * This executable specification matches the final version of [FIPS-204].
 *
 * References:
 * [FIPS-204]: National Institute of Standards and Technology. Module-Lattice-
 *     Based Digital Signature Standard. (Department of Commerce, Washington,
 *     D.C.), Federal Information Processing Standards Publication (FIPS) NIST
 *     FIPS 204. August 2024.
 *     @see https://doi.org/10.6028/NIST.FIPS.204
 *
 * @copyright Galois Inc
 * @author Marcella Hastings <marcella@galois.com>
 */
module Primitive::Asymmetric::Signature::ML_DSA::Specification where

import Primitive::Keyless::Hash::SHAKE::SHAKE128 as SHAKE128
import Primitive::Keyless::Hash::SHAKE::SHAKE256 as SHAKE256

type Byte = [8]

/**
 * Ring defined as the product of 256 elements in `Z q`, used for NTT.
 * [FIPS-204] Section 2.3 and Section 2.4.1.
 */
type Tq = [256](Z q)

/**
 * Ring of single-variable polynomials over the integers mod `X^256 + 1`.
 * [FIPS-204] Section 2.3 and Section 2.4.1.
 *
 * The `i`th element of this list represents the coefficient for the degree-`i`
 * term.
 */
type R = [256]Integer

/**
 * Wrapper function around SHAKE256, specifying the length `l` in bytes.
 * [FIPS-204] Section 3.7.
 *
 * The spec also defines a 3-part API for interacting with `H` (`Init`,
 * `Absorb`, `Squeeze`); we simulate this by generating an infinite output
 * and lazily taking things from it for each call to `Squeeze`, as described
 * in the same section.
 */
H : {l, m} (fin m) => [m][8] -> [l][8]
H str = SHAKE256::xofBytes`{8 * l} str

/**
 * Wrapper function around SHAKE128, specifying the length `l` in bytes.
 * [FIPS-204] Section 3.7.
 *
 * The spec also defines a 3-part API for interacting with `G` (`Init`,
 * `Absorb`, `Squeeze`); we simulate this by generating an infinite output
 * and lazily taking things from it for each call to `Squeeze`, as described
 * in the same section.
 */
G : {l, m} (fin m) => [m][8] -> [l][8]
G str = SHAKE128::xofBytes`{8 * l} str

parameter
    /**
     * Modulus defining the ring used throughout the protocol.
     * [FIPS-204] Section 4, Table 1.
     */
    type q = 8380417

    /**
     * Hamming weight of the mask sampled in signing.
     *
     * The spec describes this as "number of ±1s in polynomial `c`", where `c`
     * is the verifier's challenge.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint is drawn from [FIPS-204] Section 7.3, Algorithm 29.
     */
    type τ : #
    type constraint (τ <= 64)

    /**
     * Collision strength of the commitment hash `c~` component of a signature.
     * [FIPS-204] Section 4, Table 1.
     */
    type λ : #

    /**
     * Coefficient range of the commitment mask `y` used in signing.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint, which claims that γ1 must be a power of 2, is drawn
     * from [FIPS-203] Section 7.2, Algorithm 27.
     */
    type γ1 : #
    type constraint (2 ^^ (lg2 γ1) == γ1)

    /**
     * Low-order rounding range; this defines how to round the signer's
     * commitment `w`.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint is drawn from [FIPS-204] Section 7.4. The primary
     * constraint we wish to encode is that `2 * γ2` divides `q - 1`;
     * to express this, we must also require that γ2 is non-zero.
     */
    type γ2 : #
    type constraint (γ2 > 0, (q - 1) % (2 * γ2) == 0)

    /**
     * Dimensions of the matrix `A`, which is part of the public key.
     * [FIPS-204] Section 4, Table 1.
     */
    type k : #
    type ell : #

    /**
     * Private key range; the private key is a polynomial whose coefficients
     * are all in a range defined by η.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint (that η must be in the set {2, 4}) is drawn from
     * [FIPS-204] Section 7.1, Algorithm 15.
     */
    type η : #
    type constraint (η % 2 == 0, 2 <= η, η <= 4)

    /**
     * Maximum Hamming weight for the hint component of a signature.
     * [FIPS-204] Section 4, Table 1.
     */
    type ω : #

/**
 * A 512th root of unity in `Z_q`.
 * [FIPS-204] Section 4, Table 1.
 */
type ζ = 1753

/**
 * Number of dropped bits from `t` (this compresses the public key for
 * a performance optimization).
 * [FIPS-204] Section 4, Table 1.
 */
type d = 13

/**
 * Allowable error range for signature components. In signing, this is used to
 * determine if a candidate signature is valid.
 * [FIPS-204] Section 4, Table 1.
 */
type β = η * τ

/**
 * Compute a base-2 representation of the input mod `2^α` using little-endian
 * order.
 * [FIPS-204] Section 7.1, Algorithm 9.
 */
IntegerToBits : {α} (fin α, α > 0) => Integer -> [α]
IntegerToBits x = y' where
    // Step 3. Compute the value of each `y_i`.
    y = [x' % 2 | x' <- xs' | i <- [0..α - 1]]

    // Step 4. Compute value of `x'` at each iteration of the loop.
    // In Cryptol, integer division takes the floor by default.
    xs' = [x] # [x' / 2 | x' <- xs']

    // Cryptol-specific conversion: convert each Integer-typed bit to an actual
    // bit and join into a single vector.
    y' = join [(fromInteger yi) : [1] | yi <- y]

/**
 * Compute the integer value expressed by a bit string using little-endian
 * order.
 * [FIPS-204] Section 7.1, Algorithm 10.
 */
BitsToInteger : {α} (fin α, α > 0) => [α] -> Integer
BitsToInteger y = xs ! 0 where
    // Cryptol-specific conversion: separate the input into α 1-bit vectors,
    // then convert each to an integer.
    y' = map toInteger (split`{α} y)

    // Steps 1 - 4. Compute the value of `x` at each iteration of the loop.
    xs = [0] # [2 * x + y' @ (`α - i)
        | x <- xs
        | i <- [1..α]]

/**
 * The integer / bit conversion functions must invert each other.
 * This is not explicit in the spec, but we define the property anyway.
 * The parameter choices are approximately the same as some of the use cases
 * in the spec.
 * ```repl
 * :check BitsToIntegersInverts`{44}
 * :exhaust BitsToIntegersInverts`{10}
 * ```
 */
BitsToIntegersInverts : {α} (fin α, α > 0) => [α] -> Bit
property BitsToIntegersInverts x = IntegerToBits (BitsToInteger x) == x

/**
 * Generate an element in the integers mod `q` or a failure indicator.
 * [FIPS-204] Section 7.1, Algorithm 14.
 */
CoeffFromThreeBytes : Byte -> Byte -> Byte -> Option (Z q)
CoeffFromThreeBytes b0 b1 b2 = maybe_z where
    // Steps 1 - 4.
    b2' = if b2 > 127 then b2 - 128 else b2

    // We have to explicitly expand the byte strings to support the
    // operations in the next step. 32 bits gives us plenty of space.
    [bq0, bq1, bq2'] = map zext`{32} [b0, b1, b2']

    // Step 5.
    z = 2^^16 * bq2' + 2^^8 * bq1 + bq0

    // Step 6 - 7. We have to convert `z` into `Z q` manually in the successful
    // case -- note that we can't do it sooner because otherwise the condition
    // is moot.
    maybe_z = if z < `q then Some (toZ z) else None

    toZ : [32] -> Z q
    toZ b = fromInteger (toInteger b)

/**
 * Generate an element of {-η, -η + 1, ..., η} or a failure indicator.
 * [FIPS-204] Section 7.1, Algorithm 15.
 */
CoeffFromHalfByte : [4] -> Option Integer
CoeffFromHalfByte b =
    if (`η == 2) && (b < 15) then Some (2 - (toInteger b % 5))
    else
        if (`η == 4) && (b < 9) then Some (4 - toInteger b)
        else None

/**
 * Sample a polynomial in the ring `Tq`.
 * [FIPS-204] Section 7.3, Algorithm 30.
 */
RejNTTPoly : [32]Byte -> Tq
RejNTTPoly ρ = a_hat where
    // Step 2 - 3.
    ctx0 = G ρ

    // Step 4, 11. The `take` here replaces the loop condition.
    a_hat = take`{256} (sample ctx0)

    sample : [inf][8] -> [inf](Z q)
    sample GSqueeze = a_hat' where
        // Step 5. This pops the first 3 bytes off the pseudorandom stream.
        (s, ctx) = splitAt`{3} GSqueeze

        // Step 6.
        a_hat_j = CoeffFromThreeBytes (s@0) (s@1) (s@2)

        // Step 7 - 9. The recursive call here replaces the `while` loop.
        a_hat' = case a_hat_j of
            Some aj -> [aj] # (sample ctx)
            // In the spec, the sample `a_hat_j` is always added to the list,
            // and `j` is only increased if the sample was not rejected (so a
            // rejected value is overwritten in the next iteration). Here,
            // we only add `a_hat_j` if it's valid.
            None -> sample ctx

/**
 * Sample an element in `R` with coefficients in the range [-η, η].
 * [FIPS-204] Section 7.3, Algorithm 31.
 */
RejBoundedPoly: [66]Byte -> R
RejBoundedPoly ρ = a where
    // Steps 2 - 3.
    ctx0 = H ρ

    // Step 4, 17. The `take` replaces the loop condition.
    a = take`{256} (sample ctx0)

    sample : [inf][8] -> [inf]Integer
    sample HSqueeze = a' where
        // Step 5. This pops one byte off the pseudorandom stream.
        ([z] # ctx) = HSqueeze

        // Step 6 - 8. We use Cryptol-native functions instead of dividing
        // and modding `z`. See `TakeAndDropAreDivAndMod` for the equivalence.
        z0 = CoeffFromHalfByte (drop`{4} z)
        z1 = CoeffFromHalfByte (take`{4} z)

        // Step 8 - 15. The recursive calls replace the `while` loop.
        // In order to make the types work, we have to mash the two conditions
        // together and make exactly one recursive call.
        a' = case z0 of
            Some z0' -> case z1 of
                Some z1' -> [z0', z1'] # (sample ctx)
                None -> [z0'] # (sample ctx)
            None -> case z1 of
                Some z1' -> [z1'] # (sample ctx)
                None -> sample ctx

/**
 * Given a byte, the `take` function is equivalent to dividing by 16, and the
 * `drop` function is equivalent to taking the value mod 16.
 *
 * We prefer the Cryptol functions because they automatically convert from a
 * byte to a 4-bit value, which we need to call `CoeffFromHalfByte`. Here, we
 * use `zext` pad the 4-bit-vector, so we can compare it to the byte.
 * ```repl
 * :prove TakeAndDropAreDivAndMod
 * ```
 */
TakeAndDropAreDivAndMod : [8] -> Bool
property TakeAndDropAreDivAndMod z = dropIsMod && takeIsDiv where
    dropIsMod = z % 16 == zext (drop`{4} z)
    // Division of bit vectors in Cryptol automatically takes the floor.
    takeIsDiv = z / 16 == zext (take`{4} z)
